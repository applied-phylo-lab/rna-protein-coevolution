---
title: "Learning PCMBase"
author: "Alex Cope"
date: '2023-04-10'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(PCMBase,lib.loc = "~/R_dev")
library(PCMBaseCpp)
library(adaptMCMC)
require(coda)
library(tidyverse)
library(cowplot)
library(ggpubr)
library(phytools)



prior <- function(params)
{
  params.present <- names(params)
  x0.index <- which(str_detect(params.present,"(X0)|(Theta)"))
  h.index <- which(str_detect(params.present,"(H)|(Sigma)"))
  pr <- 0
  if (length(x0.index) > 0)
  {
     pr <- pr + sum(dnorm(params[x0.index],mean=0,sd=1,log=T)) # assuming same prior
  }
  if (length(h.index) > 0)
  {
     pr  <- pr + sum(dlnorm(params[h.index],meanlog = 0.25,sdlog = 1.5,log=T))
  }
  return(pr)
}

## Basing this off of example from mvMORPH. Will update later
prior_BM <- function(x)
{
  x0.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the X0.A
  x0.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for X0.B
  sigma.A <- dlnorm(x[3],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait A
  sigma.AB <- dlnorm(x[4],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of symmetric sigma matrix
  sigma.B <- dlnorm(x[5],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait B
  return(x0.A + x0.B + sigma.A + sigma.AB + sigma.B)
}

prior_OU <- function(x)
{
  x0.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the X0.A
  x0.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for X0.B
  alpha.A <- dlnorm(x[3],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alphaof trait A
  alpha.BA <- dlnorm(x[4],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.AB <- dlnorm(x[5],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.B <- dlnorm(x[6],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alpha of trait B
  theta.A <- dnorm(x[7],mean = 0, sd = 1, TRUE) # prior for the optimum of trait A
  theta.B <- dnorm(x[8],mean = 0, sd = 1, TRUE) # prior for the optimum of trait B
  sigma.A <- dlnorm(x[9],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait A
  sigma.AB <- dlnorm(x[10],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of symmetric sigma matrix
  sigma.B <- dlnorm(x[11],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait B
  return(x0.A + x0.B + alpha.A + alpha.BA + alpha.AB + alpha.B + theta.A + theta.B + sigma.A + sigma.AB + sigma.B)
}


# define the log-likelihood distribution
log_post_BM<- function(par,ll_fun)
{
  ll <- ll_fun(par)
  pr <- prior_BM(par)
  return(ll+pr)
}

# define the log-likelihood distribution
log_post_OU<- function(par,ll_fun){
  ll <- ll_fun(par)
  pr <- prior_OU(par)
  return(ll+pr)
}


hyper_prior_bayou <- function(x)
{
  alpha.A <- dlnorm(x[1],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alphaof trait A
  alpha.BA <- dlnorm(x[2],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.AB <- dlnorm(x[3],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.B <- dlnorm(x[4],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alpha of trait B
  sigma.A <- dlnorm(x[5],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait A
  sigma.AB <- dlnorm(x[6],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of symmetric sigma matrix
  sigma.B <- dlnorm(x[7],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait B
  return(alpha.A + alpha.BA + alpha.AB + alpha.B + sigma.A + sigma.AB + sigma.B)
}

prior_OU_loci <- function(x)
{
  x0.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the X0.A
  x0.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for X0.B
  theta.A <- dnorm(x[3],mean = 0, sd = 1, TRUE) # prior for the optimum of trait A
  theta.B <- dnorm(x[4],mean = 0, sd = 1, TRUE) # prior for the optimum of trait B
  return(x0.A + x0.B + theta.A + theta.B)
}

prior_OU_loci_no_root <- function(x)
{
  theta.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the optimum of trait A
  theta.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for the optimum of trait B
  return(theta.A + theta.B)
}


# Treat the first 7 parameters as the H and Sigma matrix. Remaining are X0_A, X0_B, Theta_A, Theta_B for each loci
# | Alpha A | Alpha BA | Alpha AB | Alpha B | Sigma A | Sigma AB | Sigma B |
log_post_hier<- function(par,ll_fun)
{
  
  lp <- 0
  hypr <- hyper_prior_bayou(par[1:7])
  num.genes <- (length(par)-7)/4 
  lp <- sum(unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 7 + 4*(current.loci-1) + 1
      tmp <- c(par[par.index],par[par.index+1],par[1],par[2],par[3],par[4],par[par.index+2],par[par.index+3],par[5],par[6],par[7])
      ll <- ll_fun[[current.loci]](tmp)
      pr <- prior_OU_loci(c(par[par.index],par[par.index+1],par[par.index+2],par[par.index+3]))
      ll + pr
      
    })))
  lp <- lp + hypr
  return(lp)
}




# Treat the first 7 parameters as the H and Sigma matrix. Remaining are Theta_A, Theta_B for each loci
# | Alpha A | Alpha BA | Alpha AB | Alpha B | Sigma A | Sigma AB | Sigma B |
log_post_hier_no_root <- function(par,ll_fun)
{
  lp <- 0
  hypr <- hyper_prior_bayou(par[1:7])
  num.genes <- (length(par)-7)/2
  lp <- sum(unlist(lapply(1:num.genes, function(current.loci)
    {
     tryCatch({
      par.index <- 7 + 2*(current.loci-1) + 1
      tmp <- c(NA,NA,par[1],par[2],par[3],par[4],par[par.index],par[par.index+1],par[5],par[6],par[7])
      ll <- ll_fun[[current.loci]](tmp)
      pr <- prior_OU_loci_no_root(c(par[par.index],par[par.index+1]))
      ll + pr},
      warning=function(w) retrun(NA),
      error = function(e) return(NA)
     )
    })))
  lp <- lp + hypr
  return(lp)
}


log_post_hier_no_root_fixed <- function(par,ll_fun,fixed=c())
{
  param.est <- names(par)
  hyper.param.index <- which(str_detect(par,"(H)|(Sigma)"))
  lp <- 0
  pr <- 0
  hypr <- prior(par[hyper.param.index])
  num.genes <- (length(par)-7)/2
  all.param <- c(par,fixed)
  lp <- sum(unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 7 + 2*(current.loci-1) + 1
      theta.param.names <- paste0(c("Theta_A_","Theta_B_"),current.loci)
      param.order <- c("H_A","H_BA","H_AB","H_B",theta.param.names[1],theta.param.names[2],"Sigma_A","Sigma_AB","Sigma_B")
      tmp <- all.param[param.order]
      ll <- ll_fun[[current.loci]](c(NA,NA,tmp))
      prior.vec <- par[theta.param.names]
      if (length(prior.vec) > 0)
      {
        pr <- prior(prior.vec)
      }
      ll + pr
    })))
  lp <- lp + hypr
  return(lp)
}

tracePlot <- function(model.fit,truth,type="X0_A")
{
  num.genes <- (ncol(model.fit$samples)-7)/4 
  if (type == "X0_A")
  {
    index <- seq(8,ncol(model.fit$samples),by=4)
  } else if (type == "X0_B"){
    index <- seq(9,ncol(model.fit$samples),by=4)
  } else if (type == "Theta_A"){
    index <- seq(10,ncol(model.fit$samples),by=4)
  } else if (type == "Theta_B"){
    index <- seq(11,ncol(model.fit$samples),by=4)
  }
  param.matrix <- model.fit$samples[,index]
  
  post.means <- colMeans(param.matrix)
  param.df <- data.frame(True.Values = truth[index],
                         Posterior.Mean = post.means)
  p <- ggplot(param.df,aes(x=True.Values,y=Posterior.Mean)) +
    geom_point() +
    xlab("Truth") +
    ylab("Posterior Means") +
    ggtitle(type) +
    theme_cowplot() +
    theme(aspect.ratio=1) +
    stat_cor() +
    geom_abline(intercept=0,slope = 1,linetype="dashed")
  return(p)
    
}

ba.tree <- read.nexus("Data/tree_11sp_noGpig.nex")
plot(ba.tree)
ba.tree <- force.ultrametric(ba.tree,method = "extend")
plot(ba.tree)
```




# Testing OU model

## Create tree for OU

```{r}
tip.heights <- ips::tipHeights(ba.tree)
sim.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))

```


## Simulate data under OU process

```{r}

# Simulate the traits
x0.a <- 0.25
x0.b <- -0.1
theta.a <- 0.5
theta.b <- -0.2
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = sim.tree,model = true.model,X0 = true.model$X0)

modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param,ll_fun = likFun)
```

### Start MCMC at truth

```{r warning=FALSE}

n.batch <- 50000
fit.OU <- MCMC(log_post_OU, n.batch, init = true.param, scale = rep(1,length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)




```


```{r}
# Log Posterior
plot(fit.OU$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# X0
plot(fit.OU$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.OU$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

# H matrix
plot(fit.OU$samples[,3],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU$samples[,4],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU$samples[,5],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU$samples[,6],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU$samples[,7],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU$samples[,8],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU$samples[,9],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU$samples[,10],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU$samples[,11],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```

### Random start

```{r warning = F}
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.theta.a <- rnorm(n=1,mean=0,sd=1)
start.theta.b <- rnorm(n=1,mean=0,sd=1)
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.theta.a,
               start.theta.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)


# run the mcmc

n.batch <- 50000
fit.OU.rand.start <- MCMC(log_post_OU, n.batch, init = start.val, scale = rep(1,length(start.val)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)



```

```{r}

# Log Posterior
plot(fit.OU.rand.start$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# X0
plot(fit.OU.rand.start$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.OU.rand.start$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

# H matrix
plot(fit.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.rand.start$samples[,5],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.rand.start$samples[,6],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.rand.start$samples[,7],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.rand.start$samples[,8],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.rand.start$samples[,9],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.rand.start$samples[,10],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.rand.start$samples[,11],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)




```


# Testing hierarchical model framework

```{r}

n <- 10 # number of loci
# Simulate the root state of the 2 traits across 10 loci
x0.a <- rnorm(n=n,mean=0,sd=1)
x0.b <- rnorm(n=n,mean=0,sd=1)

# Simulate the optimum of the 2 traits across 10 loci

theta.a <- rnorm(n=n,mean=0,sd=1)
theta.b <- rnorm(n=n,mean=0,sd=1)

# Use same alpha and sigma as above

sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4


data.pcm <- vector(mode="list",length=n)
likFun.list <- vector(mode="list",length=n)
for (i in 1:n)
{
  true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
  true.param <- c(x0.a[i],x0.b[i],alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a[i],theta.b[i],sigma.a,sigma.ab,sigma.b)
  PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
  
  data.pcm[[i]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  
  modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

  likFun.list[[i]] <- PCMCreateLikelihood(data.pcm[[i]], ba.tree, modelOU,metaI = PCMInfoCpp)
}
```







```{r warning=F}
# run the mcmc


start.alpha.a <- alpha.a
start.alpha.b <- alpha.b
start.alpha.ab <- alpha.ab
start.alpha.ba <- alpha.ba
start.sig.a <- sigma.a
start.sig.ab <- sigma.ab
start.sig.b <- sigma.b

true.param <- c(start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)

for (i in 1:n)
{
  true.param <- c(true.param,x0.a[i],x0.b[i],theta.a[i],theta.b[i])
}

n.batch <- 50000
fit.hier.OU <- MCMC(log_post_hier, n.batch, init = true.param, scale = rep(1,length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.list)





```

```{r}

# Log Posterior
plot(fit.hier.OU$log.p,type="l",ylab="Log(Posterior)")


# H matrix
plot(fit.hier.OU$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.hier.OU$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.hier.OU$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.hier.OU$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)


plot(fit.hier.OU$samples[,5],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.hier.OU$samples[,6],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.hier.OU$samples[,7],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


tracePlot(model.fit = fit.hier.OU,truth=true.param,type="X0_A")
tracePlot(model.fit = fit.hier.OU,truth=true.param,type="X0_B")
tracePlot(model.fit = fit.hier.OU,truth=true.param,type="Theta_A")
tracePlot(model.fit = fit.hier.OU,truth=true.param,type="Theta_B")


```



## Random Start


```{r warning = F}
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)

for (i in 1:n)
{
  start.val <- c(start.val,rnorm(n=4,mean=0,sd=1))
}


# run the mcmc


n.batch <- 50000 * 50
fit.hier.OU.rand.start <- MCMC(log_post_hier, n.batch, init = start.val, scale = rep(1,length(start.val)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.list)





```

```{r}
# Log Posterior
plot(fit.hier.OU.rand.start$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# H matrix
plot(fit.hier.OU.rand.start$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.hier.OU.rand.start$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.hier.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.hier.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)


plot(fit.hier.OU.rand.start$samples[,5],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.hier.OU.rand.start$samples[,6],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.hier.OU.rand.start$samples[,7],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="X0_A")
tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="X0_B")
tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="Theta_A")
tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="Theta_B")



```

```{r}
save(fit.hier.OU.rand.start,file="2023-04-26_mcmc_hierarchical_model_object.Rda")
```



```{r}
set.seed(15)

tree <- pbtree(n=11)

x0.a <- rnorm(n=1,mean=0,sd=1)
x0.b <- rnorm(n=1,mean=0,sd=1)

# Simulate the optimum of the 2 traits across 10 loci
theta.a <- rnorm(n=1,mean=0,sd=1)
theta.b <- rnorm(n=1,mean=0,sd=1)

# Use same alpha and sigma as above
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4


true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
data.pcm<- PCMSim(tree = tree,model = true.model,X0 = true.model$X0)


modelOU.w.root <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
modelOU.wo.root <- PCM(model="OU__Omitted_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

modelOU.w.root.NA <- modelOU.w.root
modelOU.w.root.NA$X0[] <- c(NA,NA)

likFun.w.root.wo.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root)
likFun.w.root.NA.wo.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root.NA)
likFun.wo.root.wo.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.wo.root)

likFun.w.root.w.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root,metaI = PCMInfoCpp)
likFun.w.root.NA.w.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root.NA,metaI = PCMInfoCpp)
likFun.wo.root.w.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.wo.root,metaI = PCMInfoCpp)

likFun.w.root.wo.cpp(true.param)
likFun.w.root.NA.wo.cpp(c(NA,NA,true.param[3:length(true.param)]))
likFun.wo.root.wo.cpp(true.param[3:length(true.param)])

likFun.w.root.w.cpp(true.param)
likFun.w.root.NA.w.cpp(c(NA,NA,true.param[3:length(true.param)]))
likFun.wo.root.w.cpp(true.param[3:length(true.param)])


```

## Examine warnings

```{r}
# Simulate the traits
tip.heights <- ips::tipHeights(ba.tree)
sim.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))

x0.a <- 0.05
x0.b <- 0.2
theta.a <- 0.05
theta.b <- 0.2
sigma.a <- 0.05
sigma.ab <- 0.005
sigma.b <- 0.02
alpha.a <- 0.40
alpha.b <- 0.25
alpha.ab <- 0.1
alpha.ba <- 0.15

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
data.pcm <- PCMSim(tree = sim.tree,model = true.model,X0 = true.model$X0)

modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU,metaI = PCMInfoCpp)
likFun(true.param[1:length(true.param)])

```

```{r}
param.space <- seq(0.05,1.0,by=0.05)
param.list <- list(H_A = param.space,
                   H_B = param.space) %>% 
  cross_df() %>%
  filter(H_A != H_B)
lik.result <- c()
for (i in 1:nrow(param.list))
{
  tmp <- c(true.param[1:2],unname(unlist(param.list[i,"H_A"])),true.param[4:5],unname(unlist(param.list[i,"H_B"])),true.param[7:length(true.param)])
  lik <- likFun(tmp)
  lik.result <- c(lik.result,lik)
}
param.list <- param.list %>% 
  mutate(Llik = lik.result) %>%
  arrange(desc(Llik))
param.list

truth <- param.list %>% filter(H_A == alpha.a & H_B == alpha.b)

ggplot(data = param.list) +
  #geom_tile(aes(x = H_A, y = H_B, fill = Llik)) +
  geom_contour_filled(aes(x = H_A, y = H_B, z= Llik)) +
  geom_point(data = truth, aes(x = H_A, y = H_B), color = "red") + 
  theme_cowplot()



```




# Test new hierachical model with root fixed and allowing certain parameters to be fixed

```{r warning = T}
set.seed(5)
n <- 20 # number of loci
# Simulate the root state of the 2 traits across 10 loci
x0.a <- rnorm(n=n,mean=0,sd=1)
x0.b <- rnorm(n=n,mean=0,sd=1)

# Simulate the optimum of the 2 traits across 10 loci

theta.a <- rnorm(n=n,mean=0,sd=1)
theta.b <- rnorm(n=n,mean=0,sd=1)

# Use same alpha and sigma as above

sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4


data.pcm <- vector(mode="list",length=n)
likFun.list <- vector(mode="list",length=n)
for (i in 1:n)
{
  true.param <- c(x0.a[i],x0.b[i],alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a[i],theta.b[i],sigma.a,sigma.ab,sigma.b)
  true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
  PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
  
  data.pcm[[i]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.param[1:2])
  
  modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

  likFun.list[[i]] <- PCMCreateLikelihood(data.pcm[[i]], ba.tree, modelOU,metaI = PCMInfoCpp)
}

start.alpha.a <- alpha.a
start.alpha.b <- alpha.b
start.alpha.ab <- alpha.ab
start.alpha.ba <- alpha.ba
start.sig.a <- sigma.a
start.sig.ab <- sigma.ab
start.sig.b <- sigma.b

true.param <- c(start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)
names.true.param <- c("H_A","H_BA","H_AB","H_B","Sigma_A","Sigma_AB","Sigma_B")

for (i in 1:n)
{
  true.param <- c(true.param,theta.a[i],theta.b[i])
  names.true.param <- c(names.true.param,paste0(c("Theta_A","Theta_B"),"_",i))
}
names(true.param) <- names.true.param

true.post <- log_post_hier_no_root(true.param,likFun.list)
true.post
```


```{r warning = F}


n.batch <- 10000
fit.hier.OU.no.root <- MCMC(log_post_hier_no_root, n.batch, init = true.param, scale = rep(1,length(true.param)),adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.list)

```






```{r}
# Log Posterior
plot(fit.hier.OU.no.root$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# H matrix
plot(fit.hier.OU.no.root$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.hier.OU.no.root$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.hier.OU.no.root$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.hier.OU.no.root$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)


plot(fit.hier.OU.no.root$samples[,5],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.hier.OU.no.root$samples[,6],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.hier.OU.no.root$samples[,7],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


#tracePlot(model.fit = fit.hier.OU.no.root,truth=true.param,type="X0_A")
#tracePlot(model.fit = fit.hier.OU.no.root,truth=true.param,type="X0_B")
tracePlot(model.fit = fit.hier.OU.no.root,truth=true.param,type="Theta_A")
tracePlot(model.fit = fit.hier.OU.no.root,truth=true.param,type="Theta_B")
```
```{r}
bad.fit <- fit.hier.OU.no.root$samples[500,]
for (i in 1:20)
{
 theta <- paste0(c("Theta_A_","Theta_B_"),i)
 params <- unname(c(NA,NA,bad.fit[c("H_A","H_BA","H_AB","H_B",theta,"Sigma_A","Sigma_AB","Sigma_B")]))
 ll<-likFun.list[[i]](params)
 print(ll)
}


```

