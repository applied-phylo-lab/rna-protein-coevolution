---
title: "Learning PCMBase"
author: "Alex Cope"
date: '2023-04-10'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(PCMBaseCpp)
library(adaptMCMC)
require(coda)
library(tidyverse)
library(ggpubr)
#library(LaplacesDemon)
#library(extraDistr)


## Basing this off of example from mvMORPH. Will update later
prior_BM <- function(x)
{
  x0.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the X0.A
  x0.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for X0.B
  sigma.A <- dlnorm(x[3],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait A
  sigma.AB <- dlnorm(x[4],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of symmetric sigma matrix
  sigma.B <- dlnorm(x[5],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait B
  return(x0.A + x0.B + sigma.A + sigma.AB + sigma.B)
}

prior_OU <- function(x)
{
  x0.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the X0.A
  x0.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for X0.B
  alpha.A <- dlnorm(x[3],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alphaof trait A
  alpha.BA <- dlnorm(x[4],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.AB <- dlnorm(x[5],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.B <- dlnorm(x[6],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alpha of trait B
  theta.A <- dnorm(x[7],mean = 0, sd = 1, TRUE) # prior for the optimum of trait A
  theta.B <- dnorm(x[8],mean = 0, sd = 1, TRUE) # prior for the optimum of trait B
  sigma.A <- dlnorm(x[9],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait A
  sigma.AB <- dlnorm(x[10],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of symmetric sigma matrix
  sigma.B <- dlnorm(x[11],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait B
  return(x0.A + x0.B + alpha.A + alpha.BA + alpha.AB + alpha.B + theta.A + theta.B + sigma.A + sigma.AB + sigma.B)
}


# define the log-likelihood distribution
log_post_BM<- function(par,ll_fun)
{
  ll <- ll_fun(par)
  pr <- prior_BM(par)
  return(ll+pr)
}

# define the log-likelihood distribution
log_post_OU<- function(par,ll_fun){
  ll <- ll_fun(par)
  pr <- prior_OU(par)
  return(ll+pr)
}


hyper_prior_bayou <- function(x)
{
  alpha.A <- dlnorm(x[1],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alphaof trait A
  alpha.BA <- dlnorm(x[2],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.AB <- dlnorm(x[3],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of non-symmetric H matrix
  alpha.B <- dlnorm(x[4],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the alpha of trait B
  sigma.A <- dlnorm(x[5],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait A
  sigma.AB <- dlnorm(x[6],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the off-diagonal of symmetric sigma matrix
  sigma.B <- dlnorm(x[7],meanlog = 0.25,sdlog = 1.5, log= TRUE) # prior for the standard deviations of trait B
  return(alpha.A + alpha.BA + alpha.AB + alpha.B + sigma.A + sigma.AB + sigma.B)
}

prior_OU_loci <- function(x)
{
  x0.A <- dnorm(x[1],mean = 0, sd = 1, TRUE) # prior for the X0.A
  x0.B <- dnorm(x[2],mean = 0, sd = 1, TRUE) # prior for X0.B
  theta.A <- dnorm(x[3],mean = 0, sd = 1, TRUE) # prior for the optimum of trait A
  theta.B <- dnorm(x[4],mean = 0, sd = 1, TRUE) # prior for the optimum of trait B
  return(x0.A + x0.B + theta.A + theta.B)
}

# Treat the first 7 parameters as the H and Sigma matrix. Remaining are X0_A, X0_B, Theta_A, Theta_B for each loci
# | Alpha A | Alpha BA | Alpha AB | Alpha B | Sigma A | Sigma AB | Sigma B |
log_post_hier<- function(par,ll_fun)
{
  lp <- 0
  hypr <- hyper_prior_bayou(par[1:7])
  num.genes <- (length(par)-7)/4 
  lp <- sum(unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 7 + 4*(current.loci-1) + 1
      tmp <- c(par[par.index],par[par.index+1],par[1],par[2],par[3],par[4],par[par.index+2],par[par.index+3],par[5],par[6],par[7])
      ll <- ll_fun[[current.loci]](tmp)
      pr <- prior_OU_loci(c(par[par.index],par[par.index+1],par[par.index+2],par[par.index+3]))
      ll + pr
      
    })))
  lp <- lp + hypr
  return(lp)
}


# Treat the first 7 parameters as the H and Sigma matrix. Remaining are X0_A, X0_B, Theta_A, Theta_B for each loci
# | Alpha A | Alpha BA | Alpha AB | Alpha B | Sigma A | Sigma AB | Sigma B |
log_post_hier_parallel<- function(par,ll_fun)
{
  lp <- 0
  hypr <- hyper_prior_bayou(par[1:7])
  num.genes <- (length(par)-7)/4 
  lp <- sum(unlist(mclapply(1:num.genes, function(current.loci)
    {
      par.index <- 7 + 4*(current.loci-1) + 1
      tmp <- c(par[par.index],par[par.index+1],par[1],par[2],par[3],par[4],par[par.index+2],par[par.index+3],par[5],par[6],par[7])
      ll <- ll_fun[[current.loci]](tmp)
      pr <- prior_OU_loci(c(par[par.index],par[par.index+1],par[par.index+2],par[par.index+3]))
      ll + pr
      
    },mc.cores = 4)))
  lp <- lp + hypr
  return(lp)
}


diagnostics <- function(model.object,truth = NULL,...)
{
  plot(trace$logp,type="l",main="Log Posterior",ylab="Log(Posterior)")
  
}

```

```{r}
ba.tree <- read.nexus("Data/tree_11sp_noGpig.nex")
plot(ba.tree)
ba.tree <- force.ultrametric(ba.tree,method = "extend")
plot(ba.tree)


```


## Simulate data under BM

For now, we will keep it simple. We will create a 50 species tree and simulate 

```{r}
# Simulate the traits
x0.a <- 0.5
x0.b <- -0.2
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25

true.model <- PCM(model="BM__Global_X0__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
```



## Create a log-likelihood function that can be passed to the MCMC

To save time, can create a log-likelihood function based on a given model, data, and tree that can be passed to the MCMC.

Note that you can specify models and parameterizations using the general format below. 

```{r}
modelBM <- PCM(model="BM__Global_X0__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, ba.tree, modelBM,metaI = PCMInfoCpp)
```


```{r warning=FALSE}

# run the mcmc
n.batch <- 10000
fit.BM <- MCMC(log_post_BM, n.batch, init = true.param, scale = rep(1, length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)


```


```{r}
plot(fit.BM$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.BM$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

plot(fit.BM$samples[,3],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.BM$samples[,4],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)

plot(fit.BM$samples[,5],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```


## Random start

```{r warning=FALSE}
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)

n.batch <- 50000

# run the mcmc
fit.BM.rand.start <- MCMC(log_post_BM, n.batch, init = start.val, scale = rep(1, length(start.val)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)


```



```{r}
plot(fit.BM.rand.start$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.BM.rand.start$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

plot(fit.BM.rand.start$samples[,3],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.BM.rand.start$samples[,4],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)

plot(fit.BM.rand.start$samples[,5],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)

```



# Testing OU model


## Simulate data under OU process

```{r}

# Simulate the traits
x0.a <- 0.25
x0.b <- -0.1
theta.a <- 0.5
theta.b <- -0.2
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)

modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, ba.tree, modelOU,metaI = PCMInfoCpp)
```

### Start MCMC at truth

```{r warning=FALSE}

n.batch <- 50000
fit.OU <- MCMC(log_post_OU, n.batch, init = true.param, scale = rep(1,length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)




```


```{r}

# X0
plot(fit.OU$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.OU$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

# H matrix
plot(fit.OU$samples[,3],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU$samples[,4],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU$samples[,5],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU$samples[,6],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU$samples[,7],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU$samples[,8],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU$samples[,9],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU$samples[,10],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU$samples[,11],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```

### Random start

```{r warning = F}
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.theta.a <- rnorm(n=1,mean=0,sd=1)
start.theta.b <- rnorm(n=1,mean=0,sd=1)
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.theta.a,
               start.theta.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)


# run the mcmc

n.batch <- 50000
fit.OU.rand.start <- MCMC(log_post_OU, n.batch, init = start.val, scale = rep(1,length(start.val)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)



```

```{r}
# X0
plot(fit.OU.rand.start$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.OU.rand.start$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

# H matrix
plot(fit.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.rand.start$samples[,5],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.rand.start$samples[,6],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.rand.start$samples[,7],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.rand.start$samples[,8],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.rand.start$samples[,9],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.rand.start$samples[,10],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.rand.start$samples[,11],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)




```


# Testing hierarchical model framework

```{r}

n <- 10 # number of loci
# Simulate the root state of the 2 traits across 10 loci
x0.a <- rnorm(n=n,mean=0,sd=1)
x0.b <- rnorm(n=n,mean=0,sd=1)

# Simulate the optimum of the 2 traits across 10 loci

theta.a <- rnorm(n=n,mean=0,sd=1)
theta.b <- rnorm(n=n,mean=0,sd=1)

# Use same alpha and sigma as above

sigma.a <- 0.2
sigma.ab <- 0.15
sigma.b <- 0.1
alpha.a <- 1.5
alpha.b <- 1.0
alpha.ab <- 1.25
alpha.ba <- 0.75


data.pcm <- vector(mode="list",length=n)
likFun.list <- vector(mode="list",length=n)
for (i in 1:n)
{
  true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
  true.param <- c(x0.a[i],x0.b[i],alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a[i],theta.b[i],sigma.a,sigma.ab,sigma.b)
  PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
  
  data.pcm[[i]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  
  modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

  likFun.list[[i]] <- PCMCreateLikelihood(data.pcm[[i]], ba.tree, modelOU,metaI = PCMInfoCpp)
}
```





```{r warning = F}
start.alpha.a <- alpha.a
start.alpha.b <- alpha.b
start.alpha.ab <- alpha.ab
start.alpha.ba <- alpha.ba
start.sig.a <- sigma.a
start.sig.ab <- sigma.ab
start.sig.b <- sigma.b

true.param <- c(start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)

for (i in 1:n)
{
  true.param <- c(true.param,x0.a[i],x0.b[i],theta.a[i],theta.b[i])
}

```

```{r warning=F}
# run the mcmc


n.batch <- 200000
fit.hier.OU <- MCMC(log_post_hier, n.batch, init = true.param, scale = rep(1,length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.list)





```

```{r}

# H matrix
plot(fit.hier.OU$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.hier.OU$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.hier.OU$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.hier.OU$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)


plot(fit.hier.OU$samples[,5],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.hier.OU$samples[,6],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.hier.OU$samples[,7],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```



## Random Start


```{r warning = F}
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)

for (i in 1:n)
{
  start.val <- c(start.val,rnorm(n=4,mean=0,sd=1))
}


# run the mcmc


n.batch <- 200000
fit.hier.OU.rand.start <- MCMC(log_post_hier, n.batch, init = start.val, scale = rep(1,length(start.val)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.list)





```

```{r}
# Log Posterior
plot(fit.hier.OU.rand.start$log.p,type="l",ylab="Log(Posterior)")



# H matrix
plot(fit.hier.OU.rand.start$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.hier.OU.rand.start$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.hier.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.hier.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)


plot(fit.hier.OU.rand.start$samples[,5],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.hier.OU.rand.start$samples[,6],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.hier.OU.rand.start$samples[,7],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```

```{r}

tracePlot <- function(model.fit,truth,type="X0_A")
{
  num.genes <- (ncol(model.fit$samples)-7)/4 
  if (type == "X0_A")
  {
    index <- seq(8,ncol(model.fit$samples),by=4)
  } else if (type == "X0_B"){
    index <- seq(9,ncol(model.fit$samples),by=4)
  } else if (type == "Theta_A"){
    index <- seq(10,ncol(model.fit$samples),by=4)
  } else if (type == "Theta_B"){
    index <- seq(11,ncol(model.fit$samples),by=4)
  }
  param.matrix <- model.fit$samples[,index]
  
  post.means <- colMeans(param.matrix)
  param.df <- data.frame(True.Values = truth[index],
                         Posterior.Mean = post.means)
  p <- ggplot(param.df,aes(x=True.Values,y=Posterior.Mean)) +
    geom_point() +
    xlab("Truth") +
    ylab("Posterior Means") +
    ggtitle(type) +
    theme_cowplot() +
    theme(aspect.ratio=1) +
    stat_cor() +
    geom_abline(intercept=0,slope = 1,linetype="dashed")
  return(p)
    
}

tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="X0_A")
tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="X0_B")
tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="Theta_A")
tracePlot(model.fit = fit.hier.OU.rand.start,truth=true.param,type="Theta_B")





```

