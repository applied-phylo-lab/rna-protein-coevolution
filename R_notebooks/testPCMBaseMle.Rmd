---
title: "Test PCMBase Likelihood"
author: "Alex Cope"
date: '2023-05-06'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(PCMBase,lib.loc = "~/R_dev")
library(PCMBaseCpp)
library(tidyverse)
library(cowplot)
library(bbmle)

negL.OU <- function(X0_A,
                  X0_B,
                  H_A,
                  H_BA,
                  H_AB,
                  H_B,
                  Theta_A,
                  Theta_B,
                  Sigma_A,
                  Sigma_AB,
                  Sigma_B,
                 likFun)
{
  all.par <- c(X0_A,
                  X0_B,
                  H_A,
                  H_BA,
                  H_AB,
                  H_B,
                  Theta_A,
                  Theta_B,
                  Sigma_A,
                  Sigma_AB,
                  Sigma_B)
  lik.result <- likFun(all.par,log = T)
  if(is.na(lik.result))
  {
    lik.result <- -10^30
  }
  -lik.result
}

estimateMLE <- function(data,
                        tree,
                        model.type,
                        estimate,
                        params,
                        start,
                        llFun = negL.OU,
                        metaI = PCMInfo,
                        ...
) 
{
  model <- PCM(model.type,k = 2)
  likFun <- PCMCreateLikelihood(data, tree, model,metaI = metaI)
  fixed.params <- params[which(!params %in% estimate)]
  test.mle <- mle2(llFun,
       start = as.list(start[1,estimate,drop=F]),
       fixed = as.list(start[1,fixed.params,drop=F]),
       data = list(likFun=likFun),
       ...
       )
  values <- test.mle@coef
  lik.prof <- profile(test.mle)
  param.int <- confint(lik.prof)
  param.df <- as.data.frame(param.int) %>% 
    mutate(Estimate = values) %>%
    rownames_to_column("Parameter")
  return(param.df)
}


generateRandomParams <- function()
{
  x0 <- rnorm(n=2,mean=0,sd=1)
  theta <- x0
  alpha <- runif(n=4,min=0.01,max=1)
  sigma <- runif(n=3,min=0.001,max=1)
  return(data.frame(X0_A = x0[1],
                    X0_B = x0[2],
                    H_A = alpha[1],
                    H_BA = alpha[2],
                    H_AB = alpha[3],
                    H_B = alpha[4],
                    Theta_A = theta[1],
                    Theta_B = theta[2],
                    Sigma_A = sigma[1],
                    Sigma_AB = sigma[2],
                    Sigma_B = sigma[3]))
}

generateSimData <- function(params,model.type,tree,root.state,k=2,offset=0)
{
  model <- PCM(model=model.type,k=k)
  PCMParamLoadOrStore(model, params, offset=offset, load=T)
  data.pcm <- PCMSim(tree = tree,model = model,X0 = root.state)
  return(data.pcm)
}
ba.tree <- read.nexus("../Data/tree_11sp_noGpig.nex")
plot(ba.tree)
ba.tree <- force.ultrametric(ba.tree,method = "extend")
plot(ba.tree)
```

# Issues with using Omitted_X0 in model type

Note that this involves using a local version of PCMBase that is able to handle that case where X0 is omitted.
```{r}

set.seed(15)

tree <- pbtree(n=11)

x0.a <- rnorm(n=1,mean=0,sd=1)
x0.b <- rnorm(n=1,mean=0,sd=1)

# Simulate the optimum of the 2 traits across 10 loci
theta.a <- rnorm(n=1,mean=0,sd=1)
theta.b <- rnorm(n=1,mean=0,sd=1)

# Use same alpha and sigma as above
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4


true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
data.pcm<- PCMSim(tree = tree,model = true.model,X0 = true.model$X0)


modelOU.w.root <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
modelOU.wo.root <- PCM(model="OU__Omitted_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

modelOU.w.root.NA <- modelOU.w.root
modelOU.w.root.NA$X0[] <- c(NA,NA)

likFun.w.root.wo.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root)
likFun.w.root.NA.wo.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root.NA)
likFun.wo.root.wo.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.wo.root)

likFun.w.root.w.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root,metaI = PCMInfoCpp)
likFun.w.root.NA.w.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.w.root.NA,metaI = PCMInfoCpp)
likFun.wo.root.w.cpp <- PCMCreateLikelihood(data.pcm, tree, modelOU.wo.root,metaI = PCMInfoCpp)

likFun.w.root.wo.cpp(true.param)
likFun.w.root.NA.wo.cpp(c(NA,NA,true.param[3:length(true.param)]))
likFun.wo.root.wo.cpp(true.param[3:length(true.param)])

likFun.w.root.w.cpp(true.param)
likFun.w.root.NA.w.cpp(c(NA,NA,true.param[3:length(true.param)]))
likFun.wo.root.w.cpp(true.param[3:length(true.param)])


```
As is clear from these results using just `PCMBase`, omitting X0 via the model type and setting the X0 parameters to NA in the calculation of the likelihood gives the same results. It seems that `PCMBaseCpp` is better able to handle the situation where X0 is just treated as NA. 


# Generate simulated data using Ba et al. tree

```{r}
df <- lapply(1:50,function(x) 
  {
  generateRandomParams()
}) %>% bind_rows()

model.type <- "OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

sim.data <- lapply(1:nrow(df),function(row.number) {
                    generateSimData(params = unlist(df[row.number,]),
                                    model.type = model.type,
                                    tree = ba.tree,
                                    root.state = unlist(df[row.number,c("X0_A","X0_B")])
                  )
})
```




```{r warning = F}
sim.data.params <- lapply(1:nrow(df), function(i)
{
  list(Data = sim.data[[i]],
       Parameters = df[i,])
})

names(sim.data.params) <- seq(1,nrow(df))


mle.results <- lapply(sim.data.params,function(x)
  {
    estimateMLE(x$Data,ba.tree,model.type=model.type,estimate=c("H_A","H_B"),params=colnames(df),start=x$Parameters,metaI = PCMInfoCpp)
}) %>% bind_rows(.id="Dataset")
```


```{r}
df.long <- df %>% 
  mutate(Dataset = as.character(1:nrow(df))) %>%
  pivot_longer(c(H_A,H_B),names_to="Parameter",values_to="Truth") 

truth.vs.est <- df.long %>%
  left_join(mle.results,by=c("Dataset","Parameter"))

compare.plot <- ggplot(truth.vs.est,aes(x=Truth,Estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin=`2.5 %`,ymax=`97.5 %`)) +
  theme_cowplot() +
  geom_abline(xintercept=0,slope=1,linetype="dashed") +
  stat_cor(method="spearman") +
  scale_x_log10() +
  scale_y_log10() + 
  facet_wrap(~Parameter)
compare.plot
```

# Omitting root state

```{r warning}
df.root.na <- df %>% 
  mutate(X0_A = NA,
         X0_B = NA)


model.type <- "OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

sim.data <- lapply(1:nrow(df.root.na),function(row.number) {
                    generateSimData(params = unlist(df.root.na[row.number,]),
                                    model.type = model.type,
                                    tree = ba.tree,
                                    root.state = unlist(df[row.number,c("X0_A","X0_B")])
                  )
})

sim.data.params <- lapply(1:nrow(df.root.na), function(i)
{
  list(Data = sim.data[[i]],
       Parameters = df.root.na[i,])
})
names(sim.data.params) <- seq(1,nrow(df.root.na))


```

```{r warning = F}

model.type <- "OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

mle.results.root.na <- lapply(sim.data.params,function(x)
  {
   tryCatch({
    estimateMLE(x$Data,ba.tree,model.type=model.type,estimate=c("H_A","H_B"),params=colnames(df.root.na),start=x$Parameters,metaI = PCMInfoCpp,method="Nelder-Mead",control=list(maxit=5000))
   }, 
   error = function(err){
     return(
            data.frame(Paramter = c("H_A","H_B"),`2.5 %` = c(NA,NA),`97.5%`=c(NA,NA),Estimate=c(NA,NA))
            )
     })
}) %>% 
  bind_rows(.id="Dataset")
```

```{r}
df.long <- df.root.na %>% 
  mutate(Dataset = as.character(1:nrow(df.root.na))) %>%
  pivot_longer(c(H_A,H_B),names_to="Parameter",values_to="Truth") 

truth.vs.est <- df.long %>%
  left_join(mle.results.root.na,by=c("Dataset","Parameter"))

compare.plot <- ggplot(truth.vs.est,aes(x=Truth,Estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin=`2.5 %`,ymax=`97.5 %`)) +
  theme_cowplot() +
  geom_abline(intercept=0,slope=1,linetype="dashed") +
  stat_cor(method="spearman") +
  facet_wrap(~Parameter) +
  scale_x_log10() +
  scale_y_log10()
compare.plot
```

# Test using larger tree

```{r}
# Simulate the traits
tip.heights <- ips::tipHeights(ba.tree)
sim.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))



```

```{r}
df <- lapply(1:50,function(x) 
  {
  generateRandomParams()
}) %>% bind_rows()

model.type <- "OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

sim.data <- lapply(1:nrow(df),function(row.number) {
                    generateSimData(params = unlist(df[row.number,]),
                                    model.type = model.type,
                                    tree = sim.tree,
                                    root.state = unlist(df[row.number,c("X0_A","X0_B")])
                  )
})
```




```{r warning = F}
sim.data.params <- lapply(1:nrow(df), function(i)
{
  list(Data = sim.data[[i]],
       Parameters = df[i,])
})

names(sim.data.params) <- seq(1,nrow(df))


mle.results <- lapply(sim.data.params,function(x)
  {
    estimateMLE(x$Data,sim.tree,model.type=model.type,estimate=c("H_A","H_B"),params=colnames(df),start=x$Parameters,metaI = PCMInfoCpp)
}) %>% bind_rows(.id="Dataset")
```


```{r}
df.long <- df %>% 
  mutate(Dataset = as.character(1:nrow(df))) %>%
  pivot_longer(c(H_A,H_B),names_to="Parameter",values_to="Truth") 

truth.vs.est <- df.long %>%
  left_join(mle.results,by=c("Dataset","Parameter"))

compare.plot <- ggplot(truth.vs.est,aes(x=Truth,Estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin=`2.5 %`,ymax=`97.5 %`)) +
  theme_cowplot() +
  geom_abline(xintercept=0,slope=1,linetype="dashed") +
  stat_cor(method="spearman") +
  scale_x_log10() +
  scale_y_log10() + 
  facet_wrap(~Parameter)
compare.plot
```

## Omitting root state

```{r warning}
df.root.na <- df %>% 
  mutate(X0_A = NA,
         X0_B = NA)

sim.data.params <- lapply(1:nrow(df.root.na), function(i)
{
  list(Data = sim.data[[i]],
       Parameters = df.root.na[i,])
})
names(sim.data.params) <- seq(1,nrow(df.root.na))


```

```{r warning = F}

mle.results.root.na <- lapply(sim.data.params,function(x)
  {
   tryCatch({
    estimateMLE(x$Data,sim.tree,model.type=model.type,estimate=c("H_A","H_B"),params=colnames(df.root.na),start=x$Parameters,metaI = PCMInfoCpp,method="Nelder-Mead",control=list(maxit=5000))
   }, 
   error = function(err){
     return(
            data.frame(Paramter = c("H_A","H_B"),`2.5 %` = c(NA,NA),`97.5%`=c(NA,NA),Estimate=c(NA,NA))
            )
     })
}) %>% 
  bind_rows(.id="Dataset")
```

```{r}
df.long <- df.root.na %>% 
  mutate(Dataset = as.character(1:nrow(df.root.na))) %>%
  pivot_longer(c(H_A,H_B),names_to="Parameter",values_to="Truth") 

truth.vs.est <- df.long %>%
  left_join(mle.results.root.na,by=c("Dataset","Parameter"))

compare.plot <- ggplot(truth.vs.est,aes(x=Truth,Estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin=`2.5 %`,ymax=`97.5 %`)) +
  theme_cowplot() +
  geom_abline(intercept=0,slope=1,linetype="dashed") +
  stat_cor(method="spearman") +
  facet_wrap(~Parameter) +
  scale_x_log10() +
  scale_y_log10()
compare.plot
```

