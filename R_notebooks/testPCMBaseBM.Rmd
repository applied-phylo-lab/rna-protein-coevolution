---
title: "Test Brownian Motion"
author: "Alex Cope"
date: '2023-05-08'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(PCMBase,lib.loc = "~/R_dev")
library(PCMBaseCpp)
library(adaptMCMC)
require(coda)
library(tidyverse)
library(cowplot)
library(ggpubr)
library(phytools)
```

```{r}

prior <- function(params)
{
  params.present <- names(params)
  x0.index <- which(str_detect(params.present,"(X0)|(Theta)"))
  h.index <- which(str_detect(params.present,"(H)|(Sigma)"))
  pr <- 0
  if (length(x0.index) > 0)
  {
     pr <- pr + sum(dnorm(params[x0.index],mean=0,sd=1,log=T)) # assuming same prior
  }
  if (length(h.index) > 0)
  {
     pr  <- pr + sum(dlnorm(params[h.index],meanlog = 0.25,sdlog = 1.5,log=T))
  }
  return(pr)
}

# define the log-likelihood distribution
log_post_BM<- function(par,ll_fun)
{
  ll <- ll_fun(par)
  pr <- prior(par)
  return(ll+pr)
}




```


# Read in tree
```{r}
ba.tree <- read.nexus("Data/tree_11sp_noGpig.nex")
plot(ba.tree)
ba.tree <- force.ultrametric(ba.tree,method = "extend")
plot(ba.tree)


```



## Simulate data under BM

For now, we will keep it simple. We will create a 50 species tree and simulate 

```{r}
# Simulate the traits
x0.a <- 0.5
x0.b <- -0.2
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25

true.model <- PCM(model="BM__Global_X0__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,sigma.a,sigma.ab,sigma.b)
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
```



## Create a log-likelihood function that can be passed to the MCMC

To save time, can create a log-likelihood function based on a given model, data, and tree that can be passed to the MCMC.

Note that you can specify models and parameterizations using the general format below. 

```{r}
modelBM <- PCM(model="BM__Global_X0__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, ba.tree, modelBM,metaI = PCMInfoCpp)
```


```{r warning=FALSE}

# run the mcmc
n.batch <- 10000
fit.BM <- MCMC(log_post_BM, n.batch, init = true.param, scale = rep(1, length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)


```


```{r}
plot(fit.BM$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.BM$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

plot(fit.BM$samples[,3],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.BM$samples[,4],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)

plot(fit.BM$samples[,5],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```


## Random start

```{r warning=FALSE}
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)

n.batch <- 50000

# run the mcmc
fit.BM.rand.start <- MCMC(log_post_BM, n.batch, init = start.val, scale = rep(1, length(start.val)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun)


```



```{r}
plot(fit.BM.rand.start$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.BM.rand.start$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

plot(fit.BM.rand.start$samples[,3],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.BM.rand.start$samples[,4],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)

plot(fit.BM.rand.start$samples[,5],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)

```


