---
title: "LaplacesDemon OU"
author: "Alex Cope"
date: '2023-05-10'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(PCMBase,lib.loc = "~/R_dev")
library(PCMBaseCpp)
library(LaplacesDemon,lib.loc = "~/R_dev/")
require(coda)
library(tidyverse)
library(cowplot)
library(ggpubr)
library(phytools)
library(extraDistr)
source("/data2/cope/rna-protein-coevolution/R_notebooks/local_functions.R")



prior_ln <- function(params)
{
  params.present <- names(params)
  x0.index <- which(str_detect(params.present,"(X0)|(Theta)"))
  h.index <- which(str_detect(params.present,"(H)|(Sigma)"))
  pr <- 0
  if (length(x0.index) > 0)
  {
     pr <- pr + sum(dnorm(params[x0.index],mean=0,sd=1,log=T)) # assuming same prior
  }
  if (length(h.index) > 0)
  {
     pr  <- pr + sum(dlnorm(params[h.index],meanlog = 0.25,sdlog = 1.5,log=T))
  }
  return(pr)
}

prior_cauchy <- function(params)
{
  params.present <- names(params)
  x0.index <- which(str_detect(params.present,"(X0)|(Theta)"))
  h.index <- which(str_detect(params.present,"(H)|(Sigma)"))
  pr <- 0
  if (length(x0.index) > 0)
  {
     pr <- pr + sum(dnorm(params[x0.index],mean=0,sd=1,log=T)) # assuming same prior
  }
  if (length(h.index) > 0)
  {
     pr  <- pr + sum(dhcauchy(params[h.index],sigma=0.1,log=T))
  }
  return(pr)
}

# define the log-likelihood distribution
log_post_OU<- function(par,ll_fun,include.root=T,stationary=F,prior = prior_ln){
  if (!include.root)
  {
    par <- c(NA,NA,par)
  } else if (stationary){
    par.index <- which(str_detect(names(par),"Theta"))
    par <- c(par[par.index],par)
  }
  ll <- ll_fun(par)
  pr <- prior(par)
  return(ll+pr)
}

```




```{r}
set.seed(25)
tip.heights <- ips::tipHeights(ba.tree)
sim.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))
plot(sim.tree)

x0.a <- 0.25
x0.b <- -0.1
theta.a <- x0.a # assume stationarity
theta.b <- x0.b # assume stationarity
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
names(true.param) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)

pos.h <- grep("H",names(true.param)) - 2 
pos.sigma <- grep("Sigma",names(true.param)) - 2 
pos.theta <- grep("Theta",names(true.param)) - 2 

data.pcm <- PCMSim(tree = sim.tree,model = true.model,X0 = true.model$X0)

modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param[3:11],ll_fun = likFun,stationary = T,prior=prior_cauchy)
```


```{r}
PGF <- function(Data)
{
  H_A <- rnorm(1,mean = 0.25,sd = 1.5)
  H_BA <- rnorm(1,mean = 0.25,sd = 1.5)
  H_AB <- rnorm(1,mean = 0.25,sd = 1.5)
  H_B <- rnorm(1,mean = 0.25,sd = 1.5)
  Theta_A <- rnorm(n=1,mean=0,sd=1)
  Theta_B <- rnorm(n=1,mean=0,sd=1)
  Sigma_A <- rnorm(1,mean = 0.25,sd = 1.5)
  Sigma_AB <- rnorm(1,mean = 0.25,sd = 1.5)
  Sigma_B <- rnorm(1,mean = 0.25,sd = 1.5)
  return(c(H_A,H_BA,H_AB,H_B,Theta_A,Theta_B,Sigma_A,Sigma_AB,Sigma_B))
}

MyData <- list(ll_fun = likFun,
 PGF=PGF,
 mon.names = "LP",
 parm.names=names(true.param[3:11]), 
 pos.h = pos.h, 
 pos.sigma=pos.sigma, 
 pos.theta=pos.theta,
 prior=prior_ln,
 stationary=T,
 propose.log = T,
 correct.transform = F)

Model <- function(parm, Data)
{
 ### Parameters
 if (Data$propose.log)
 {
   h <- exp(parm[Data$pos.h])
   sigma <- exp(parm[Data$pos.sigma])
 } else {
   h <- parm[Data$pos.h]
   sigma <- parm[Data$pos.sigma]
 }
 theta <- parm[Data$pos.theta]
 prior <- Data$prior
 ll_fun <- Data$ll_fun
 if (Data$stationary)
 {
   tmp.parm <- c(parm[pos.theta],h,parm[pos.theta],sigma)
 } else {
   tmp.parm <- c(parm[1:2],h,parm[pos.theta],sigma)
 }
 names(tmp.parm) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
 LL <- ll_fun(tmp.parm)
 pr <- prior(tmp.parm[3:11])
 if (Data$correct.transform)
 {
  correction <- sum(log(sigma)) + sum(log(h))
 } else {
   correction <- 0
 }
 LP <- LL + pr + correction
 Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=1, parm=parm)
 return(Modelout)
}
```


```{r warning = F}
log.true.param <- c(log(true.param[3:6]),true.param[7:8],log(true.param[9:11]))

#approx <- LaplaceApproximation(Model,jitter(log.true.param),Data = MyData)
fit.RAM <- LaplacesDemon(Model,
                     MyData,
                     Initial.Values = log.true.param,
                     Iterations = 10000,
                     #Covar = covar.mat,
                     Algorithm = "RAM",
                     Thinning = 1,
                     Debug = list(DB.Model = F,
                                  DB.chol = T),
                     Specs = list(alpha.star = 0.44,
                                  B = list(c(1,4,7,9),c(5,6),c(2,3,8)),
                                  Dist="N",
                                  gamma = 2/3,
                                  n=0
                                  ))

pdf("/data2/cope/rna-protein-coevolution/example_mcmc_laplace_demon_single_OU_10000.pdf")
plot(fit.RAM$Monitor[,"LP"],type="l",ylab="Log(Posterior)")
plot(fit.RAM$Posterior1[,"H_A"],type="l",ylab=expression(alpha["A"]))
abline(h=log.true.param[1])
plot(fit.RAM$Posterior1[,"H_BA"],type="l",ylab=expression(alpha["BA"]))
abline(h=log.true.param[2])
plot(fit.RAM$Posterior1[,"H_AB"],type="l",ylab=expression(alpha["AB"]))
abline(h=log.true.param[3])
plot(fit.RAM$Posterior1[,"H_B"],type="l",ylab=expression(alpha["B"]))
abline(h=log.true.param[4])
plot(fit.RAM$Posterior1[,"Theta_A"],type="l",ylab=expression(theta["A"]))
abline(h=log.true.param[5])
plot(fit.RAM$Posterior1[,"Theta_B"],type="l",ylab=expression(theta["B"]))
abline(h=log.true.param[6])
plot(fit.RAM$Posterior1[,"Sigma_A"],type="l",ylab=expression(sigma["A"]))
abline(h=log.true.param[7])
plot(fit.RAM$Posterior1[,"Sigma_AB"],type="l",ylab=expression(sigma["AB"]))
abline(h=log.true.param[8])
plot(fit.RAM$Posterior1[,"Sigma_B"],type="l",ylab=expression(sigma["B"]))
abline(h=log.true.param[9])
dev.off()

```

```{r warning = F}
fit.RAM.rand.start <- LaplacesDemon(Model,
                     MyData,
                     Initial.Values = PGF(),
                     Iterations = 40000,
                     #Covar = covar.mat,
                     Algorithm = "RAM",
                     Thinning = 1,
                     Debug = list(DB.Model = F,
                                   DB.chol = T),
                     Specs = list(alpha.star = 0.44,
                                  B = list(c(1,4,7,9),c(5,6),c(2,3,8)),
                                  Dist="N",
                                  gamma = 2/3,
                                  n=0
                                  ))

plot(fit.RAM.rand.start$Monitor[,"LP"],type="l",ylab="Log(Posterior)")
plot(fit.RAM.rand.start$Posterior1[,"H_A"],type="l",ylab=expression(alpha["A"]))
abline(h=log.true.param[1])
plot(fit.RAM.rand.start$Posterior1[,"H_BA"],type="l",ylab=expression(alpha["BA"]))
abline(h=log.true.param[2])
plot(fit.RAM.rand.start$Posterior1[,"H_AB"],type="l",ylab=expression(alpha["AB"]))
abline(h=log.true.param[3])
plot(fit.RAM.rand.start$Posterior1[,"H_B"],type="l",ylab=expression(alpha["B"]))
abline(h=log.true.param[4])
plot(fit.RAM.rand.start$Posterior1[,"Theta_A"],type="l",ylab=expression(theta["A"]))
abline(h=log.true.param[5])
plot(fit.RAM.rand.start$Posterior1[,"Theta_B"],type="l",ylab=expression(theta["B"]))
abline(h=log.true.param[6])
plot(fit.RAM.rand.start$Posterior1[,"Sigma_A"],type="l",ylab=expression(sigma["A"]))
abline(h=log.true.param[7])
plot(fit.RAM.rand.start$Posterior1[,"Sigma_AB"],type="l",ylab=expression(sigma["AB"]))
abline(h=log.true.param[8])
plot(fit.RAM.rand.start$Posterior1[,"Sigma_B"],type="l",ylab=expression(sigma["B"]))
abline(h=log.true.param[9])

```

# Test hierarchical model


```{r}
n <- 10 # number of loci
# Simulate the root state of the 2 traits across 10 loci
x0.a <- rnorm(n=n,mean=0,sd=1)
x0.b <- rnorm(n=n,mean=0,sd=1)

# Assume at stationarity
theta.a <- x0.a
theta.b <- x0.b

# Use same alpha and sigma as above

sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4


data.pcm <- vector(mode="list",length=n)
likFun.list <- vector(mode="list",length=n)
for (i in 1:n)
{
  true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
  true.param <- c(x0.a[i],x0.b[i],alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a[i],theta.b[i],sigma.a,sigma.ab,sigma.b)
  PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
  
  data.pcm[[i]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  
  modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

  likFun.list[[i]] <- PCMCreateLikelihood(data.pcm[[i]], ba.tree, modelOU,metaI = PCMInfoCpp)
}

true.param <- c(alpha.a,
               alpha.ba,
               alpha.ab,
               alpha.b,
               sigma.a,
               sigma.ab,
               sigma.b)
names.true.param <- c("H_A","H_BA","H_AB","H_B","Sigma_A","Sigma_AB","Sigma_B")

for (i in 1:n)
{
  true.param <- c(true.param,theta.a[i],theta.b[i])
  names.true.param <- c(names.true.param,paste0(c("Theta_A","Theta_B"),"_",i))
}
names(true.param) <- names.true.param

pos.h <- grep("H",names(true.param)) 
pos.sigma <- grep("Sigma",names(true.param))
pos.theta <- grep("Theta",names(true.param))

blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(1,4,5,7)
blockwise.sample.list[[2]] <- c(2,3,6)
for (i in 1:n)
{
  pos.theta.i <- grep(paste0("Theta_[AB]_",i,"$"),names(true.param))
  blockwise.sample.list[[i+2]] <- pos.theta.i
}

```


```{r}
MyData_hier <- list(ll_fun = likFun.list,
 mon.names = "LP",
 parm.names=names(true.param), 
 pos.h = pos.h, 
 pos.sigma=pos.sigma, 
 pos.theta=pos.theta,
 prop = 1:length(true.param),
 prior=prior_ln)

Model <- function(parm, Data)
{
 ### Parameters
 h <- exp(parm[Data$pos.h])
 sigma <- exp(parm[Data$pos.sigma])
 num.genes <- (length(parm)-7)/2
 prior <- Data$prior
 ll_fun <- Data$ll_fun
 LL <- sum(unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 7 + 2*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index],parm[par.index+1],h,parm[par.index],parm[par.index+1],sigma))
      ll
    })
    )
 )
 hyper.pr <-  sum(dlnorm(c(h,sigma),meanlog = 0.25,sdlog = 1.5,log=T))
 pr <- sum(dnorm(parm[8:length(parm)],mean = 0,sd = 1,log=T))
 LP <- LL + pr + hyper.pr
 Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=1, parm=parm)
 return(Modelout)
}

Model_attempt <- function(parm, Data)
{
 ### Parameters
 pos.theta <- Data[["pos.theta"]]
 h <- exp(parm[Data[["pos.h"]]])
 sigma <- exp(parm[Data[["pos.sigma"]]])
 #prior <- Data[["prior"]]
 ll_fun <- Data[["ll_fun"]]
 prop <- Data[["prop"]]
 gene.ll <- Data[["Gene.LL"]]
 if (prop[1] >= 8 && !is.null(gene.ll))
 {
   gene.index <- floor((prop[1] - 7 - 1)/2) + 1
   other.ll <- sum(gene.ll[-gene.index])
   current.ll <- ll_fun[[gene.index]](c(parm[prop[1]],parm[prop[2]],h,parm[prop[1]],parm[prop[2]],sigma))
   LL <- current.ll + other.ll
   gene.ll[gene.index] <- current.ll
   
 } else {
   num.genes <- (length(parm)-7)/2
   gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
      {
        par.index <- 7 + 2*(current.loci-1) + 1
        ll <- ll_fun[[current.loci]](c(parm[par.index],parm[par.index+1],h,parm[par.index],parm[par.index+1],sigma))
        ll
      })
      )
   LL <- sum(gene.ll)
 }
 hyper.pr <-  sum(dlnorm(c(h,sigma),meanlog = 0.25,sdlog = 1.5,log=T))
 pr <- sum(dnorm(parm[8:length(parm)],mean = 0,sd = 1,log=T))
 LP <- LL + pr + hyper.pr
 Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=1, parm=parm,Parameter.LL=gene.ll)
 return(Modelout)
}

```


```{r}
log.true.param <- c(log(true.param[1:7]),true.param[8:length(true.param)])
fit.AMWG.hier <- LaplacesDemon(Model,
                     MyData_hier,
                     Initial.Values = log.true.param,
                     Iterations = 10000,
                     #Covar = covar.mat,
                     Algorithm = "AMWG",
                     Thinning = 1,
                     Debug = list(DB.Model = F,
                                  DB.chol = T),
                     Specs = list(B = blockwise.sample.list,
                                  n=0,
                                  Periodicity=50))

```


```{r warning = F}
log.true.param <- c(log(true.param[1:7]),true.param[8:length(true.param)])

fit.RAM.hier <- LaplacesDemon(Model,
                     MyData_hier,
                     Initial.Values = log.true.param,
                     Iterations = 20000,
                     #Covar = covar.mat,
                     Algorithm = "RAM",
                     Thinning = 1,
                     Debug = list(DB.Model = F,
                                  DB.chol = T),
                     Specs = list(alpha.star = 0.234,
                                  B = blockwise.sample.list,
                                  Dist="N",
                                  gamma = 2/3,
                                  n=0
                                  ))

#pdf("/data2/cope/rna-protein-coevolution//example_mcmc_laplace_demon_hier_blockwise.pdf")
plot(fit.RAM.hier$Monitor[,"LP"],type="l",ylab="Log(Posterior)")
plot(fit.RAM.hier$Posterior1[,"H_A"],type="l",ylab=expression(alpha["A"]))
abline(h=log.true.param[1])
plot(fit.RAM.hier$Posterior1[,"H_BA"],type="l",ylab=expression(alpha["BA"]))
abline(h=log.true.param[2])
plot(fit.RAM.hier$Posterior1[,"H_AB"],type="l",ylab=expression(alpha["AB"]))
abline(h=log.true.param[3])
plot(fit.RAM.hier$Posterior1[,"H_B"],type="l",ylab=expression(alpha["B"]))
abline(h=log.true.param[4])
plot(fit.RAM.hier$Posterior1[,"Sigma_A"],type="l",ylab=expression(sigma["A"]))
abline(h=log.true.param[5])
plot(fit.RAM.hier$Posterior1[,"Sigma_AB"],type="l",ylab=expression(sigma["AB"]))
abline(h=log.true.param[6])
plot(fit.RAM.hier$Posterior1[,"Sigma_B"],type="l",ylab=expression(sigma["B"]))
abline(h=log.true.param[7])

for (i in 8:ncol(fit.RAM.hier$Posterior1))
{
  plot(fit.RAM.hier$Posterior1[,i],type="l",ylab=expression(theta))
  abline(h=log.true.param[i])
}




```



```{r warning = F}
source("local_functions.R")
log.true.param <- c(log(true.param[1:7]),true.param[8:length(true.param)])
fit.RAM.hier.local <- LaplacesDemon_local(Model_attempt,
                     MyData_hier,
                     Initial.Values = log.true.param,
                     Iterations = 10000,
                     Algorithm = "HARM",
                     Thinning = 1,
                     Debug = list(DB.Model = F,
                                  DB.chol = T),
                     Specs = list(alpha.star = 0.44,
                                  B = blockwise.sample.list,
                                  n=0
                                  ))

#pdf("/data2/cope/rna-protein-coevolution//example_mcmc_laplace_demon_hier_blockwise.pdf")
plot(fit.RAM.hier.local$Monitor[,"LP"],type="l",ylab="Log(Posterior)")
plot(fit.RAM.hier.local$Posterior1[,"H_A"],type="l",ylab=expression(alpha["A"]))
abline(h=log.true.param[1])
plot(fit.RAM.hier.local$Posterior1[,"H_BA"],type="l",ylab=expression(alpha["BA"]))
abline(h=log.true.param[2])
plot(fit.RAM.hier.local$Posterior1[,"H_AB"],type="l",ylab=expression(alpha["AB"]))
abline(h=log.true.param[3])
plot(fit.RAM.hier.local$Posterior1[,"H_B"],type="l",ylab=expression(alpha["B"]))
abline(h=log.true.param[4])
plot(fit.RAM.hier.local$Posterior1[,"Sigma_A"],type="l",ylab=expression(sigma["A"]))
abline(h=log.true.param[5])
plot(fit.RAM.hier.local$Posterior1[,"Sigma_AB"],type="l",ylab=expression(sigma["AB"]))
abline(h=log.true.param[6])
plot(fit.RAM.hier.local$Posterior1[,"Sigma_B"],type="l",ylab=expression(sigma["B"]))
abline(h=log.true.param[7])

for (i in 8:ncol(fit.RAM.hier.local$Posterior1))
{
  plot(fit.RAM.hier.local$Posterior1[,i],type="l",ylab=expression(theta))
  abline(h=log.true.param[i])
}




```


```{r}
n <- 0
iter <- 20000
gamma <- 2/3
alpha.star <- 0.234
VarCov.prev<- diag(nrow=1500)
S <- t(chol(VarCov.prev))
U <- rnorm(ncol(S))
eta <- min(1, nrow(VarCov.prev)*{n + iter}^(-gamma))
Iden.Mat <- diag(nrow=nrow(VarCov.prev))
current <- 0.5
system.time({
  VarCov.test <- S %*% {Iden.Mat + eta*(min(1, current - alpha.star)) * U %*% t(U) / sum(U*U)} %*% t(S)
  S.next <- t(chol(VarCov.test))
}
)
system.time({
S.next.c <- adapt_S(S,U,current,iter,target=alpha.star,gamma=gamma)
Var.Cov.test.c <- S.next.c %*% t(S.next.c)
})

```


## Test OUOU model from Bartoszek et al. 2012

```{r}
listParameterizationsOU <- PCMListParameterizations(structure(0.0, class="OU"))
listParameterizationsOU$X0 <- listParameterizationsOU$X0[1]
listParameterizationsOU$H <- listParameterizationsOU$H[12]
listParameterizationsOU$Sigma_x <- listParameterizationsOU$Sigma_x[2]
listParameterizationsOU$Sigmae_x <- listParameterizationsOU$Sigmae_x[c(5,7)]

dtParameterizations <- PCMTableParameterizations(
  structure(0.0, class="OU"), listParameterizations = listParameterizationsOU)

PCMGenerateParameterizations(structure(0.0, class="OU"), 
                             tableParameterizations = dtParameterizations[])


```

## Not quite the model but close
```{r}
n <- 50 # number of loci

psi.a <- rnorm(n=n,mean=0,sd=1)
psi.b <- rnorm(n=n,mean=0,sd=1)

# Use same alpha and sigma as above

sigma.a <- 0.5
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
b <- 1.5 
alpha.ab <-  -alpha.a * b

data.pcm <- vector(mode="list",length=n)
likFun.list <- vector(mode="list",length=n)
for (i in 1:n)
{
  true.model <- PCM(model="OU__Global_X0__Schur_UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Transformable_Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
  true.param <- c(psi.a[i],
                  psi.b[i],
                  alpha.a,
                  alpha.ab,
                  alpha.b,
                  psi.a[i],
                  psi.b[i],
                  sigma.a,
                  sigma.b)
  PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
  
  data.pcm[[i]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)[,1:length(ba.tree$tip.label)]
  
  modelOU <- PCM(model="OU__Global_X0__Schur_UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Transformable_Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

  likFun.list[[i]] <- PCMCreateLikelihood(data.pcm[[i]], ba.tree, modelOU,metaI = PCMInfoCpp)
}

true.param <- c(alpha.a,
                alpha.b,
                alpha.ab,
               sigma.a,
               sigma.b)
names.true.param <- c("H_A",
                      "H_B",
                      "Q",
                      "Sigma_A",
                      "Sigma_B")


for (i in 1:n)
{
  true.param <- c(true.param,psi.a[i],psi.b[i])
  names.true.param <- c(names.true.param,paste0(c("Psi_A","Psi_B"),"_",i))
}
names(true.param) <- names.true.param

pos.h <- grep("H",names(true.param)) 
pos.b <- grep("Q",names(true.param))
pos.sigma <- grep("Sigma",names(true.param))
pos.psi <- grep("Psi",names(true.param))

blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(1,3,4)
blockwise.sample.list[[2]] <- c(2,5)
for (i in 1:n)
{
  pos.theta.i <- grep(paste0("Psi_[AB]_",i,"$"),names(true.param))
  blockwise.sample.list[[i+2]] <- pos.theta.i
}

```


```{r}
source("local_functions.R")
MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LL"),
                    parm.names=names(true.param), 
                    pos.h = pos.h, 
                    pos.b = pos.b,
                    pos.sigma=pos.sigma, 
                    pos.psi=pos.psi,
                    prop = 1:length(true.param),
                    N=length(ba.tree$tip.label)*n*2)


Model_OUOU <- function(parm, Data)
{
  ### Parameters
  pos.psi <- Data[["pos.psi"]]
  h <- exp(parm[Data[["pos.h"]]])
  b <- parm[Data[["pos.b"]]]
  #b <- 1.5
  sigma <- exp(parm[Data[["pos.sigma"]]])
  ll_fun <- Data[["ll_fun"]]
  prop <- Data[["prop"]]
  gene.ll <- Data[["Gene.LL"]]
  if (prop[1] >= pos.psi[1] && !is.null(gene.ll))
  {
    gene.index <- floor((prop[1] - 5 - 1)/2) + 1
    other.ll <- sum(gene.ll[-gene.index])
    current.ll <- ll_fun[[gene.index]](c(parm[prop[1]],# + b*parm[prop[2]],
                                         parm[prop[2]],
                                         h[1],
                                         b,
                                         h[2],
                                         parm[prop[1]],# + b*parm[prop[2]],
                                         parm[prop[2]],
                                         sigma))
    LL <- current.ll + other.ll
    gene.ll[gene.index] <- current.ll
    
  } else {
    num.genes <- (length(parm)-5)/2
    gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 5 + 2*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index],# + b*parm[par.index+1],
                                     parm[par.index+1],
                                     h[1],
                                     b,
                                     h[2],
                                     parm[par.index],# + b*parm[par.index+1],
                                     parm[par.index+1],
                                     sigma))
      ll
    })
    )
    LL <- sum(gene.ll)
  }
  hyper.pr <-  sum(dlnorm(c(h,sigma),meanlog = 0.25,sdlog = 1.5,log=T)) + dnorm(b,mean = 0,sd = 1,log=T)
  pr <- sum(dnorm(parm[pos.psi[1]:length(parm)],mean = 0,sd = 1,log=T))
  LP <- LL + pr + hyper.pr
  Modelout <- list(LP=LP,Dev=-2*LL, Monitor=c(LP,LL), yhat=1, parm=parm,Parameter.LL=gene.ll)
  return(Modelout)
}


log.true.param <- c(log(true.param[1:2]),true.param[3],log(true.param[4:5]),true.param[6:length(true.param)])
#log.true.param <- c(log(true.param[1:3]),log(true.param[4:5]),true.param[6:length(true.param)])
#log.true.param <- c(log(true.param[1:4]),true.param[5:length(true.param)])

Model_OUOU(log.true.param,MyData_OUOU)
fit.RAM.hier.local <- LaplacesDemon_local(Model_OUOU,
                                          MyData_OUOU,
                                          Initial.Values = log.true.param,
                                          Iterations = 20000,
                                          Algorithm = "RAM",
                                          Thinning = 1,
                                          Debug = list(DB.Model = F,
                                                       DB.chol = T),
                                          Specs = list(alpha.star = 0.44,
                                                       B = blockwise.sample.list,
                                                       Dist="t",
                                                       gamma = 2/3,
                                                       n=0
                                          ))


plot(fit.RAM.hier.local$Monitor[,"LP"],type="l",ylab="Log(Posterior)")
plot(fit.RAM.hier.local$Monitor[,"LL"],type="l",ylab="Log(Likelihood)")
plot(fit.RAM.hier.local$Posterior1[,"H_A"],type="l",ylab=expression(alpha["A"]))
abline(h=log.true.param[1])
plot(fit.RAM.hier.local$Posterior1[,"H_B"],type="l",ylab=expression(alpha["B"]))
abline(h=log.true.param[2])
plot(fit.RAM.hier.local$Posterior1[,"Q"],type="l",ylab="Q")
abline(h=log.true.param[3])
plot(fit.RAM.hier.local$Posterior1[,"Sigma_A"],type="l",ylab=expression(sigma["A"]))
abline(h=log.true.param[4])
plot(fit.RAM.hier.local$Posterior1[,"Sigma_B"],type="l",ylab=expression(sigma["B"]))
abline(h=log.true.param[5])

for (i in 6:ncol(fit.RAM.hier.local$Posterior1))
{
  plot(fit.RAM.hier.local$Posterior1[,i],type="l",ylab=expression(theta))
  abline(h=log.true.param[i])
}


```

## Attempt at the model

```{r}
n <- 20 # number of loci

psi.a <- rnorm(n=n,mean=0,sd=1)
psi.b <- rnorm(n=n,mean=0,sd=1)

# Use same alpha and sigma as above

sigma.a <- 0.5
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
b <- 1.5 

## Get root state
x0.b <- psi.b
x0.a <- psi.a + b*x0.b



data.pcm <- vector(mode="list",length=n)
likFun.list <- vector(mode="list",length=n)
for (i in 1:n)
{
  true.model <- PCM(model="OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
  true.param <- c(x0.a[i],
                  x0.b[i],
                  alpha.a,
                  0,
                  -alpha.a * b,
                  alpha.b,
                  x0.a[i],
                  x0.b[i],
                  sigma.a,
                  sigma.b)
  PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)
  
  data.pcm[[i]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  
  modelOU <- PCM(model="OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

  likFun.list[[i]] <- PCMCreateLikelihood(data.pcm[[i]], ba.tree, modelOU,metaI = PCMInfoCpp)
}

true.param <- c(alpha.a,
                alpha.b,
                b,
                sigma.a,
                sigma.b)
names.true.param <- c("H_A",
                      "H_B",
                      "Q",
                      "Sigma_A",
                      "Sigma_B")


for (i in 1:n)
{
  true.param <- c(true.param,psi.a[i],psi.b[i])
  names.true.param <- c(names.true.param,paste0(c("Psi_A","Psi_B"),"_",i))
}
names(true.param) <- names.true.param

pos.h <- grep("H",names(true.param)) 
pos.b <- grep("Q",names(true.param))
pos.sigma <- grep("Sigma",names(true.param))
pos.psi <- grep("Psi",names(true.param))

blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(1,2,3,4,5)
#blockwise.sample.list[[2]] <- c(3)
for (i in 1:n)
{
  pos.theta.i <- grep(paste0("Psi_[AB]_",i,"$"),names(true.param))
  blockwise.sample.list[[i+1]] <- pos.theta.i
}

```


```{r warning = F}
source("local_functions.R")
MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LL"),
                    parm.names=names(true.param), 
                    pos.h = pos.h, 
                    pos.b = pos.b,
                    pos.sigma=pos.sigma, 
                    pos.psi=pos.psi,
                    prop = 1:length(true.param),
                    N=length(ba.tree$tip.label)*n*2)


Model_OUOU <- function(parm, Data)
{
  ### Parameters
  pos.psi <- Data[["pos.psi"]]
  h <- exp(parm[Data[["pos.h"]]])
  b <- parm[Data[["pos.b"]]]
  sigma <- exp(parm[Data[["pos.sigma"]]])
  ll_fun <- Data[["ll_fun"]]
  prop <- Data[["prop"]]
  gene.ll <- Data[["Gene.LL"]]
  if (prop[1] >= pos.psi[1] && !is.null(gene.ll))
  {
    gene.index <- floor((prop[1] - 5 - 1)/2) + 1
    other.ll <- sum(gene.ll[-gene.index])
    current.ll <- ll_fun[[gene.index]](c(parm[prop[1]] + b*parm[prop[2]],
                                         parm[prop[2]],
                                         h[1],
                                         0,
                                         -h[1] * b,
                                         h[2],
                                         parm[prop[1]] + b*parm[prop[2]],
                                         parm[prop[2]],
                                         sigma))
    LL <- current.ll + other.ll
    gene.ll[gene.index] <- current.ll
    
  } else {
    num.genes <- (length(parm)-5)/2
    gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 5 + 2*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index] + b*parm[par.index+1],
                                     parm[par.index+1],
                                     h[1],
                                     0,
                                     -h[1] * b,
                                     h[2],
                                     parm[par.index] + b*parm[par.index+1],
                                     parm[par.index+1],
                                     sigma))
      ll
    })
    )
    LL <- sum(gene.ll)
  }
  hyper.pr <-  sum(dlnorm(c(h,sigma),meanlog = 0.25,sdlog = 1.5,log=T)) + dnorm(b,mean = 0,sd = 1,log=T)
  pr <- sum(dnorm(parm[pos.psi[1]:length(parm)],mean = 0,sd = 1,log=T))
  LP <- LL + pr + hyper.pr
  Modelout <- list(LP=LP,Dev=-2*LL, Monitor=c(LP,LL), yhat=1, parm=parm,Parameter.LL=gene.ll)
  return(Modelout)
}


log.true.param <- c(log(true.param[1:2]),true.param[3],log(true.param[4:5]),true.param[6:length(true.param)])
#log.true.param <- c(log(true.param[1:3]),log(true.param[4:5]),true.param[6:length(true.param)])
#log.true.param <- c(log(true.param[1:4]),true.param[5:length(true.param)])

Model_OUOU(log.true.param,MyData_OUOU)
fit.RAM.model <- LaplacesDemon_local(Model_OUOU,
                                          MyData_OUOU,
                                          Initial.Values = log.true.param,
                                          Iterations = 10000,
                                          Algorithm = "RAM",
                                          Thinning = 1,
                                          Debug = list(DB.Model = F,
                                                       DB.chol = T),
                                          Specs = list(alpha.star = 0.44,
                                                       B = blockwise.sample.list,
                                                       Dist="t",
                                                       gamma = 2/3,
                                                       n=0
                                          ))


plot(fit.RAM.model$Monitor[,"LP"],type="l",ylab="Log(Posterior)")
plot(fit.RAM.model$Monitor[,"LL"],type="l",ylab="Log(Likelihood)")
plot(fit.RAM.model$Posterior1[,"H_A"],type="l",ylab=expression(alpha["A"]))
abline(h=log.true.param[1])
plot(fit.RAM.model$Posterior1[,"H_B"],type="l",ylab=expression(alpha["B"]))
abline(h=log.true.param[2])
plot(fit.RAM.model$Posterior1[,"Q"],type="l",ylab="Q")
abline(h=log.true.param[3])
plot(fit.RAM.model$Posterior1[,"Sigma_A"],type="l",ylab=expression(sigma["A"]))
abline(h=log.true.param[4])
plot(fit.RAM.model$Posterior1[,"Sigma_B"],type="l",ylab=expression(sigma["B"]))
abline(h=log.true.param[5])

for (i in 6:ncol(fit.RAM.model$Posterior1))
{
  plot(fit.RAM.model$Posterior1[,i],type="l",ylab=expression(theta))
  abline(h=log.true.param[i])
}


```






```{r}

model.1 <- "OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"
model.2 <- "OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"
pcm.1 <- PCM(model.1,k=2)
pcm.2 <- PCM(model.2,k=2)
pcm.2.trans <- PCMApplyTransformation(pcm.2)
true.param <- c(x0.a[1],
                  x0.b[1],
                  alpha.a,
                  0,
                  -alpha.a * b,
                  alpha.b,
                  x0.a[1],
                  x0.b[1],
                  sigma.a,
                  sigma.b)
PCMParamLoadOrStore(pcm.1, true.param, offset=0, load=T)
PCMParamLoadOrStore(pcm.2, true.param, offset=0, load=T)

data <- PCMSim(ba.tree,pcm.1,pcm.1$X0)

lmr.1 <- PCMLmr(data,tree = ba.tree,model = pcm.1)
lmr.2 <- PCMLmr(data,tree = ba.tree,model = pcm.2)
lmr.2.trans <- PCMLmr(data,tree = ba.tree,model = pcm.2.trans)

```


# Test mRNA model



```{r}
Model_OUOU_correlated_evolution_mRNA <- function(parm, Data)
{
  ### Parameters
  pos.psi <- Data[["pos.psi"]]
  h <- exp(parm[Data[["pos.h"]]])
  b <- parm[Data[["pos.b"]]]
  c.val <- parm[Data[["pos.c"]]]
  sigma <- exp(parm[Data[["pos.sigma"]]])
  ll_fun <- Data[["ll_fun"]]
  prop <- Data[["prop"]]
  gene.ll <- Data[["Gene.LL"]]
  if (prop[1] >= pos.psi[1] && !is.null(gene.ll))
  {
    gene.index <- floor((prop[1] - 6 - 1)/2) + 1
    other.ll <- sum(gene.ll[-gene.index])
    current.ll <- ll_fun[[gene.index]](c(parm[prop[1]] + b*parm[prop[2]],
                                         parm[prop[2]],
                                         h[1],
                                         0,
                                         h[2] * c.val - h[1] * b,
                                         h[2],
                                         parm[prop[1]] + b*parm[prop[2]],
                                         parm[prop[2]],
                                         sigma[1],
                                         c.val*sigma[2],
                                         sigma[2]))
    LL <- current.ll + other.ll
    gene.ll[gene.index] <- current.ll
    
  } else {
    num.genes <- (length(parm)-6)/2
    gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- 6 + 2*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index] + b*parm[par.index+1],
                                     parm[par.index+1],
                                     h[1],
                                     0,
                                     h[2] * c.val - h[1] * b,
                                     h[2],
                                     parm[par.index] + b*parm[par.index+1],
                                     parm[par.index+1],
                                     sigma[1],
                                     c.val*sigma[2],
                                     sigma[2]))
      ll
    })
    )
    LL <- sum(gene.ll)
  }
  HYP <-  sum(dlnorm(c(h,sigma),meanlog = log(log(2)/(173/2)),sdlog = 1.5,log=T)) + sum(dnorm(c(c.val,b),mean = 0,sd = 1,log=T))
  PR <- sum(dnorm(parm[pos.psi[1]:length(parm)],mean = 0,sd = 1,log=T))
  LP <- LL + PR + HYP
  Modelout <- list(LP=LP,Dev=-2*LL, Monitor=c(LP,LL,PR,HYP), yhat=1, parm=parm,Parameter.LL=gene.ll)
  return(Modelout)
}
```


```{r}
options(PCMBase.Threshold.EV = 1e-07)
options(PCMBase.Threshold.SV = 1e-08)

num.loci <- 50 # number of loci
model.type <- "OU__Global_X0__Global_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

ba.tree <- ape::read.nexus("../Data/tree_11sp_noGpig.nex")
ba.tree <- phytools::force.ultrametric(ba.tree,method = "extend") # tree is not ultrametric due to apparent rounding error
# tip.heights <- ips::tipHeights(ba.tree)
# ba.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))

num.species <- length(ba.tree$tip.label)
# Simulate the optima of the 2 traits across loci
psi.x <- rnorm(n=num.loci,mean=0,sd=1)
psi.y <- rnorm(n=num.loci,mean=0,sd=1)

sigma.x.mean <- -2.8
sigma.y.mean <- -2.1
alpha.x.mean <- -3.8
alpha.y.mean <- -3.2
b.mean <- 0.65
c.mean <- 0.25

data.pcm <- vector(mode="list",length=num.loci)
likFun.list <- vector(mode="list",length=num.loci)
true.param <- c(alpha.y.mean,alpha.x.mean,b.mean,c.mean,sigma.y.mean,sigma.x.mean)
names(true.param) <- c("H_Y_Mean","H_X_Mean","Q_Mean","C_Mean","Sigma_Y_Mean","Sigma_X_Mean")
for(j in 1:num.loci)
{
  ## Get root state
  x0 <- psi.x[j]
  y0 <- psi.y[j] + b.mean*x0
  true.model <- PCM(model=model.type,k=2)
  param <- c(y0,
             x0,
             exp(alpha.y.mean),
             0,
             exp(alpha.x.mean)*c.mean - b.mean*exp(alpha.y.mean),
             exp(alpha.x.mean),
             y0,
             x0,
             exp(sigma.y.mean),
             c.mean*exp(sigma.x.mean),
             exp(sigma.x.mean))
  PCMParamLoadOrStore(true.model, param, offset=0, load=T)
  
  gene.param <- c(psi.y[j],psi.x[j])
  names(gene.param) <- paste0(c("Psi_Y_","Psi_X_"),j)
  true.param <- c(true.param,gene.param)
  modelOU <- PCM(model= model.type,k=2)
  data.pcm[[j]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  data.pcm[[j]] <- data.pcm[[j]][,1:num.species]
  likFun.list[[j]] <- PCMCreateLikelihood(data.pcm[[j]], ba.tree,modelOU,metaI = PCMInfoCpp)
} 




```

```{r warning = F}

#start.values <- true.param[-c(2,4,6,8,10)]
start.values <- true.param
pos.h <- grep("H_[YX]_Mean",names(start.values)) 

pos.b.mean <- grep("Q_Mean",names(start.values))
pos.c.mean <- grep("C_Mean",names(start.values))
  
pos.sigma <- grep("Sigma_[YX]_Mean",names(start.values)) 

pos.psi <- grep("Psi",names(start.values))

MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LL","PR","HYP"),
                    parm.names=names(start.values), 
                    pos.h = pos.h,
                    pos.b = pos.b.mean,
                    pos.c = pos.c.mean,
                    pos.sigma=pos.sigma,
                    pos.psi=pos.psi,
                    prop = 1:length(start.values),
                    N=length(ba.tree$tip.label)*num.loci*2)



blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(2,6)
blockwise.sample.list[[2]] <- c(3,4)
blockwise.sample.list[[3]] <- c(1,5)
num.block <- length(blockwise.sample.list)
for (i in 1:num.loci)
{
  pos.psi.i <- grep(paste0("Psi_[YX]_",i,"$"),names(start.values))
  blockwise.sample.list[[i+num.block]] <- c(pos.psi.i)
}

adapt.fit.mrna.cor <- LaplacesDemon_local(Model_OUOU_correlated_evolution_mRNA,
                                   MyData_OUOU,
                                   Initial.Values = start.values,
                                   Iterations = 5000,
                                   Algorithm = "RAM",
                                   Thinning = 5,
                                   Debug = list(DB.Model = F,
                                                DB.chol = T),
                                   Specs = list(alpha.star = 0.35,
                                                B = blockwise.sample.list,
                                                Dist="t",
                                                gamma = 2/3,
                                                n=0
                                   ))

```
```{r}
plot(adapt.fit.mrna.cor$Monitor[,"LP"],type="l",main="Log(Posterior)")
plot(adapt.fit.mrna.cor$Monitor[,"LL"],type="l",main="Log(Likelihood)")
plot(adapt.fit.mrna.cor$Monitor[,"PR"],type="l",main="Log(Prior)")
plot(adapt.fit.mrna.cor$Posterior1[,"H_Y_Mean"],type="l",main="H_Y_Mean")
abline(h=alpha.y.mean)
plot(adapt.fit.mrna.cor$Posterior1[,"H_X_Mean"],type="l",main="H_X_Mean")
abline(h=alpha.x.mean)
plot(adapt.fit.mrna.cor$Posterior1[,"Q_Mean"],type="l",main="Q_Mean")
abline(h=0.65)
plot(adapt.fit.mrna.cor$Posterior1[,"C_Mean"],type="l",main="C_Mean")
abline(h=0.25)
plot(adapt.fit.mrna.cor$Posterior1[,"Sigma_Y_Mean"],type="l",main="Sigma_Y_Mean")
abline(h=sigma.y.mean)
plot(adapt.fit.mrna.cor$Posterior1[,"Sigma_X_Mean"],type="l",main="Sigma_X_Mean")
abline(h=sigma.x.mean)

```


# Test full model 
```{r}
ModelOUOU_full_model <- function(parm, Data)
{
  
  ### Parameters
  ## Means are for a lognormal distribution, represent mean on the log-scale. Can be negative.
  hy.mean.prior <- parm[Data[["pos.hy.mean"]]]
  hy.std.prior <- exp(parm[Data[["pos.hy.std"]]])
  
  hx.mean.prior <- parm[Data[["pos.hx.mean"]]]
  hx.std.prior <- exp(parm[Data[["pos.hx.std"]]])
  
  b.mean.prior <- parm[Data[["pos.b.mean"]]]
  b.std.prior <- exp(parm[Data[["pos.b.std"]]])
  
  sigmay.mean.prior <- parm[Data[["pos.sigmay.mean"]]]
  sigmay.std.prior <- exp(parm[Data[["pos.sigmay.std"]]])
  
  sigmax.mean.prior <- parm[Data[["pos.sigmax.mean"]]]
  sigmax.std.prior <- exp(parm[Data[["pos.sigmax.std"]]])
  
  hy <- exp(parm[Data[["pos.hy"]]])
  hx <- exp(parm[Data[["pos.hx"]]])
  b <- parm[Data[["pos.b"]]]
  sigmay <- exp(parm[Data[["pos.sigmay"]]])
  sigmax <- exp(parm[Data[["pos.sigmax"]]])
  pos.psi <- Data[["pos.psi"]]
  
  ll_fun <- Data[["ll_fun"]]
  prop <- Data[["prop"]]
  gene.ll <- Data[["Gene.LL"]]
  offset <- 10
  ## Can use pos.psi[1] as check because parm should first have hyperparameters and then gene-specific parameters
  if (prop[1] >= pos.psi[1] && !is.null(gene.ll))
  {
    gene.index <- floor((prop[1] - offset - 1)/7) + 1
    other.ll <- sum(gene.ll[-gene.index])
    current.ll <- ll_fun[[gene.index]](c(parm[prop[1]] + parm[prop[5]]*parm[prop[2]],
                                         parm[prop[2]],
                                         exp(parm[prop[3]]),
                                         0,
                                         -exp(parm[prop[3]]) * parm[prop[5]],
                                         exp(parm[prop[4]]),
                                         parm[prop[1]] + parm[prop[5]]*parm[prop[2]],
                                         parm[prop[2]],
                                         exp(parm[prop[6]]),
                                         exp(parm[prop[7]])))
  
    LL <- current.ll + other.ll
    gene.ll[gene.index] <- current.ll
  } else {
    num.genes <- (length(parm)-offset)/7
    gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- offset + 7*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index] + parm[par.index+4]*parm[par.index+1],
                                     parm[par.index+1],
                                     exp(parm[par.index+2]),
                                     0,
                                     -exp(parm[par.index+2]) * parm[par.index+4],
                                     exp(parm[par.index+3]),
                                     parm[par.index] + parm[par.index+4]*parm[par.index+1],
                                     parm[par.index+1],
                                     exp(parm[par.index+5]),
                                     exp(parm[par.index+6])))
      
      ll
    })
    )
    LL <- sum(gene.ll)
  }
  
  PR <- sum(dlnorm(hy,hy.mean.prior,hy.std.prior,log=T)) +
    sum(dlnorm(hx,hx.mean.prior,hx.std.prior,log=T)) +
    sum(dlnorm(sigmay,sigmay.mean.prior,sigmay.std.prior,log=T)) +
    sum(dlnorm(sigmax,sigmax.mean.prior,sigmax.std.prior,log=T)) +
    sum(dnorm(b,mean = b.mean.prior,sd = b.std.prior,log=T)) +
    sum(dnorm(parm[pos.psi],mean = 0,sd = 1,log=T))
  
  HYP <- sum(dhcauchy(c(sigmay.std.prior,
                     sigmax.std.prior,
                     b.std.prior,
                     hx.std.prior,
                     hy.std.prior),
                     sigma=1,log=T)) +
  # sum(dunif(c(sigmay.std.prior,
  #                    sigmax.std.prior,
  #                    b.std.prior,
  #                    hx.std.prior,
  #                    hy.std.prior),
  #                    min=0,max=2,log=T)) +
         sum(dunif(c(hy.mean.prior,
               hx.mean.prior,
               sigmay.mean.prior,
               sigmax.mean.prior),min=log(0.008),max=0,log=T)) +
         dnorm(b.mean.prior,mean=0,sd=1,log=T)
  LP.unc <- LL + PR + HYP
  ## Apply correction for log-transformation of hyperparameters. Using lognormal for other parameters already corrects for this, but currently using uniform for hyperparameters
  LP <- LP.unc + sum(log(c(hy.std.prior,
                       hx.std.prior,
                       b.std.prior,
                       sigmay.std.prior,
                       sigmax.std.prior)))# + sum(c(hy,hx,sigmay,sigmax))
  
  ## Parameter.LL is a bit of misnomer, is actually log posterior for each gene (no hyperpriors)
  Modelout <- list(LP=LP,Dev=-2*LL, Monitor=c(LP,LP.unc,LL,PR,HYP), yhat=1, parm=parm,Parameter.LL=gene.ll)
  return(Modelout)
}




```


```{r}
options(PCMBase.Threshold.EV = 1e-10)
options(PCMBase.Threshold.SV = 1e-11)
set.seed(20) # for reproducibility
num.loci <- 100 # number of loci
model.type <- "OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

ba.tree <- ape::read.nexus("../Data/tree_11sp_noGpig.nex")
ba.tree <- phytools::force.ultrametric(ba.tree,method = "extend") # tree is not ultrametric due to apparent rounding error
tip.heights <- ips::tipHeights(ba.tree)
min.edge <- min(ba.tree$edge.length)
ba.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))
ba.tree <- paleotree::minBranchLength(ba.tree,min.edge,modifyRootAge = F)

num.species <- length(ba.tree$tip.label)
# Simulate the optima of the 2 traits across loci
psi.x <- rnorm(n=num.loci,mean=0,sd=1)
psi.y <- rnorm(n=num.loci,mean=0,sd=1)

sigma.x.mean <- -2.3
sigma.y.mean <- -2.1
alpha.x.mean <- log(log(2)/(173/2)) 
alpha.y.mean <- log(log(2)/(173/4))
b.mean <- 0.65

data.pcm <- vector(mode="list",length=num.loci)
likFun.list <- vector(mode="list",length=num.loci)
true.param <- c(alpha.y.mean,log(1.5),alpha.x.mean,log(1.5),b.mean,log(0.25),sigma.y.mean,log(1.5),sigma.x.mean,log(1.5))
names(true.param) <- c("H_Y_Mean","H_Y_Std","H_X_Mean","H_X_Std","Q_Mean","Q_Std","Sigma_Y_Mean","Sigma_Y_Std","Sigma_X_Mean","Sigma_X_Std")
for(j in 1:num.loci)
{
  sigma.x <- rlnorm(n=1,meanlog = sigma.x.mean,sdlog = 1.5)
  sigma.y <- rlnorm(n=1,meanlog = sigma.y.mean,sdlog = 1.5)
  alpha.x <- rlnorm(n=1,meanlog = alpha.x.mean,sdlog = 1.5)
  alpha.y <- rlnorm(n=1,meanlog = alpha.y.mean,sdlog = 1.5)
  b <- rnorm(n=1,mean=b.mean,sd=0.25)
  ## Get root state
  x0 <- psi.x[j]
  y0 <- psi.y[j] + b*x0
  true.model <- PCM(model=model.type,k=2)
  param <- c(y0,
             x0,
             alpha.y,
             0,
             -b*alpha.y,
             alpha.x,
             y0,
             x0,
             sigma.y,
             sigma.x)
  PCMParamLoadOrStore(true.model, param, offset=0, load=T)
  
  gene.param <- c(psi.y[j],psi.x[j],log(alpha.y),log(alpha.x),b,log(sigma.y),log(sigma.x))
  names(gene.param) <- paste0(c("Psi_Y_","Psi_X_","H_Y_","H_X_","Q_","Sigma_Y_","Sigma_X_"),j)
  true.param <- c(true.param,gene.param)
  modelOU <- PCM(model= model.type,k=2)
  data.pcm[[j]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  data.pcm[[j]] <- data.pcm[[j]][,1:num.species]
  likFun.list[[j]] <- PCMCreateLikelihood(data.pcm[[j]], ba.tree,modelOU,metaI = PCMInfoCpp)
} 



```


```{r warning = F}

#start.values <- true.param[-c(2,4,6,8,10)]
start.values <- true.param
pos.hy.mean <- grep("H_Y_Mean",names(start.values)) 
pos.hy.std <- grep("H_Y_Std",names(start.values)) 
pos.hx.mean <- grep("H_X_Mean",names(start.values)) 
pos.hx.std <- grep("H_X_Std",names(start.values)) 

pos.b.mean <- grep("Q_Mean",names(start.values))
pos.b.std <- grep("Q_Std",names(start.values))

pos.sigmay.mean <- grep("Sigma_Y_Mean",names(start.values)) 
pos.sigmay.std <- grep("Sigma_Y_Std",names(start.values)) 
pos.sigmax.mean <- grep("Sigma_X_Mean",names(start.values)) 
pos.sigmax.std <- grep("Sigma_X_Std",names(start.values)) 


pos.hx <- grep("H_X_[0-9]+",names(start.values)) 
pos.hy <- grep("H_Y_[0-9]+",names(start.values)) 
pos.b <- grep("Q_[0-9]+",names(start.values))
pos.sigmax <- grep("Sigma_X_[0-9]+",names(start.values))
pos.sigmay <- grep("Sigma_Y_[0-9]+",names(start.values))

pos.psi <- grep("Psi",names(start.values))

MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LP.unc","LL","PR","HYP"),
                    parm.names=names(start.values), 
                    pos.hy.mean = pos.hy.mean,
                    pos.hy.std = pos.hy.std,
                    pos.hx.mean = pos.hx.mean,
                    pos.hx.std = pos.hx.std,
                    pos.b.mean = pos.b.mean,
                    pos.b.std = pos.b.std,
                    pos.sigmay.mean = pos.sigmay.mean,
                    pos.sigmay.std = pos.sigmay.std, 
                    pos.sigmax.mean = pos.sigmax.mean,
                    pos.sigmax.std = pos.sigmax.std,
                    pos.hy = pos.hy, 
                    pos.hx = pos.hx, 
                    pos.b = pos.b,
                    pos.sigmax=pos.sigmax,
                    pos.sigmay=pos.sigmay,
                    pos.psi=pos.psi,
                    prop = 1:length(start.values),
                    N=length(ba.tree$tip.label)*num.loci*2)



blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(3,4,9,10)
blockwise.sample.list[[2]] <- c(5,6)
blockwise.sample.list[[3]] <- c(1,2,7,8)
num.block <- length(blockwise.sample.list)
for (i in 1:num.loci)
{
  pos.psi.i <- grep(paste0("Psi_[YX]_",i,"$"),names(start.values))
  pos.h.i <- grep(paste0("H_[YX]_",i,"$"),names(start.values))
  pos.q.i <- grep(paste0("Q_",i,"$"),names(start.values))
  pos.sigma.i <- grep(paste0("Sigma_[YX]_",i,"$"),names(start.values))
  blockwise.sample.list[[i+num.block]] <- c(pos.psi.i,pos.h.i,pos.q.i,pos.sigma.i)
}

adapt.fit.full <- LaplacesDemon_local(ModelOUOU_full_model,
                                   MyData_OUOU,
                                   Initial.Values = start.values,
                                   Iterations = 10000,
                                   Algorithm = "RAM",
                                   Thinning = 1,
                                   Debug = list(DB.Model = F,
                                                DB.chol = T),
                                   Specs = list(alpha.star = 0.44,
                                                B = blockwise.sample.list,
                                                Dist="t",
                                                gamma = 2/3,
                                                n=0
                                   ))

```

```{r}
plot(adapt.fit.full$Monitor[,"LP"],type="l",main="Log(Posterior)")
plot(adapt.fit.full$Monitor[,"LL"],type="l",main="Log(Likelihood)")
plot(adapt.fit.full$Monitor[,"PR"],type="l",main="Log(Prior)")
plot(adapt.fit.full$Posterior1[,"H_Y_Mean"],type="l",main="H_Y_Mean")
abline(h=alpha.y.mean)
plot(adapt.fit.full$Posterior1[,"H_Y_Std"],type="l",main="H_Y_Std")
abline(h=log(1.5))
plot(adapt.fit.full$Posterior1[,"H_X_Mean"],type="l",main="H_X_Mean")
abline(h=alpha.x.mean)
plot(adapt.fit.full$Posterior1[,"H_X_Std"],type="l",main="H_X_Std")
abline(h=log(1.5))
plot(adapt.fit.full$Posterior1[,"Q_Mean"],type="l",main="Q_Mean")
abline(h=0.65)
plot(adapt.fit.full$Posterior1[,"Q_Std"],type="l",main="Q_Std")
abline(h=log(0.25))
plot(adapt.fit.full$Posterior1[,"Sigma_Y_Mean"],type="l",main="Sigma_Y_Mean")
abline(h=sigma.y.mean)
plot(adapt.fit.full$Posterior1[,"Sigma_Y_Std"],type="l",main="Sigma_Y_Std")
abline(h=log(1.5))
plot(adapt.fit.full$Posterior1[,"Sigma_X_Mean"],type="l",main="Sigma_X_Mean")
abline(h=sigma.x.mean)
plot(adapt.fit.full$Posterior1[,"Sigma_X_Std"],type="l",main="Sigma_X_Std")
abline(h=log(1.5))

```


# Test $\beta$ shared model 
```{r}
ModelOUOU_shared_beta <- function(parm, Data)
{
  
  ### Parameters
  ## Means are for a lognormal distribution, represent mean on the log-scale. Can be negative.
  hy.mean.prior <- parm[Data[["pos.hy.mean"]]]
  hy.std.prior <- exp(parm[Data[["pos.hy.std"]]])
  
  hx.mean.prior <- parm[Data[["pos.hx.mean"]]]
  hx.std.prior <- exp(parm[Data[["pos.hx.std"]]])
  
  
  sigmay.mean.prior <- parm[Data[["pos.sigmay.mean"]]]
  sigmay.std.prior <- exp(parm[Data[["pos.sigmay.std"]]])
  
  sigmax.mean.prior <- parm[Data[["pos.sigmax.mean"]]]
  sigmax.std.prior <- exp(parm[Data[["pos.sigmax.std"]]])
  
  hy <- exp(parm[Data[["pos.hy"]]])
  hx <- exp(parm[Data[["pos.hx"]]])
  b <- parm[Data[["pos.b"]]]
  sigmay <- exp(parm[Data[["pos.sigmay"]]])
  sigmax <- exp(parm[Data[["pos.sigmax"]]])
  pos.psi <- Data[["pos.psi"]]
  
  ll_fun <- Data[["ll_fun"]]
  prop <- Data[["prop"]]
  gene.ll <- Data[["Gene.LL"]]
  offset <- 9
  ## Can use pos.psi[1] as check because parm should first have hyperparameters and then gene-specific parameters
  if (prop[1] >= pos.psi[1] && !is.null(gene.ll))
  {
    gene.index <- floor((prop[1] - offset - 1)/6) + 1
    other.ll <- sum(gene.ll[-gene.index])
    current.ll <- ll_fun[[gene.index]](c(parm[prop[1]] + b*parm[prop[2]],
                                         parm[prop[2]],
                                         exp(parm[prop[3]]),
                                         0,
                                         -exp(parm[prop[3]]) * b,
                                         exp(parm[prop[4]]),
                                         parm[prop[1]] + b*parm[prop[2]],
                                         parm[prop[2]],
                                         exp(parm[prop[5]]),
                                         exp(parm[prop[6]])))
  
    LL <- current.ll + other.ll
    gene.ll[gene.index] <- current.ll
  } else {
    num.genes <- (length(parm)-offset)/6
    gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- offset + 6*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index] + b*parm[par.index+1],
                                     parm[par.index+1],
                                     exp(parm[par.index+2]),
                                     0,
                                     -exp(parm[par.index+2]) * b,
                                     exp(parm[par.index+3]),
                                     parm[par.index] + b*parm[par.index+1],
                                     parm[par.index+1],
                                     exp(parm[par.index+4]),
                                     exp(parm[par.index+5])))
      
      ll
    })
    )
    LL <- sum(gene.ll)
  }
  
  PR <- sum(dlnorm(hy,hy.mean.prior,hy.std.prior,log=T)) +
    sum(dlnorm(hx,hx.mean.prior,hx.std.prior,log=T)) +
    sum(dlnorm(sigmay,sigmay.mean.prior,sigmay.std.prior,log=T)) +
    sum(dlnorm(sigmax,sigmax.mean.prior,sigmax.std.prior,log=T)) +
    sum(dnorm(b,mean = 0,sd = 1,log=T)) +
    sum(dnorm(parm[pos.psi],mean = 0,sd = 1,log=T))
  
  HYP <- sum(dinvgamma(c(sigmay.std.prior,
                          sigmax.std.prior,hy.std.prior,hx.std.prior),
                        alpha=5,beta=5,log=T)) +
         sum(dunif(c(hy.mean.prior,
               hx.mean.prior,
               sigmay.mean.prior,
               sigmax.mean.prior),min=log(0.008),max=0,log=T))
  LP.unc <- LL + PR + HYP
  ## Apply correction for log-transformation of hyperparameters. Using lognormal for other parameters already corrects for this, but currently using uniform for hyperparameters
  LP <- LP.unc + sum(log(c(hy.std.prior,
                       hx.std.prior,
                       sigmay.std.prior,
                       sigmax.std.prior)))# + sum(c(hy,hx,sigmay,sigmax))
  
  ## Parameter.LL is a bit of misnomer, is actually log posterior for each gene (no hyperpriors)
  Modelout <- list(LP=LP,Dev=-2*LL, Monitor=c(LP,LP.unc,LL,PR,HYP), yhat=1, parm=parm,Parameter.LL=gene.ll)
  return(Modelout)
}




```


```{r}
options(PCMBase.Threshold.EV = 1e-12)
options(PCMBase.Threshold.SV = 1e-13)
set.seed(20) # for reproducibility
num.loci <- 100 # number of loci
model.type <- "OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

ba.tree <- ape::read.nexus("../Data/tree_11sp_noGpig.nex")
ba.tree <- phytools::force.ultrametric(ba.tree,method = "extend") # tree is not ultrametric due to apparent rounding error
tip.heights <- ips::tipHeights(ba.tree)
min.edge <- min(ba.tree$edge.length)
ba.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))
ba.tree <- paleotree::minBranchLength(ba.tree,min.edge,modifyRootAge = F)

num.species <- length(ba.tree$tip.label)
# Simulate the optima of the 2 traits across loci
psi.x <- rnorm(n=num.loci,mean=0,sd=1)
psi.y <- rnorm(n=num.loci,mean=0,sd=1)

sigma.x.mean <- -2.3
sigma.y.mean <- -2.1
alpha.x.mean <- log(log(2)/(173/2)) 
alpha.y.mean <- log(log(2)/(173/4))
b.mean <- 0.65

data.pcm <- vector(mode="list",length=num.loci)
likFun.list <- vector(mode="list",length=num.loci)
true.param <- c(alpha.y.mean,log(1.5),alpha.x.mean,log(1.5),b.mean,log(0.25),sigma.y.mean,log(1.5),sigma.x.mean,log(1.5))
names(true.param) <- c("H_Y_Mean","H_Y_Std","H_X_Mean","H_X_Std","Q_Mean","Q_Std","Sigma_Y_Mean","Sigma_Y_Std","Sigma_X_Mean","Sigma_X_Std")
for(j in 1:num.loci)
{
  sigma.x <- rlnorm(n=1,meanlog = sigma.x.mean,sdlog = 1.5)
  sigma.y <- rlnorm(n=1,meanlog = sigma.y.mean,sdlog = 1.5)
  alpha.x <- rlnorm(n=1,meanlog = alpha.x.mean,sdlog = 1.5)
  alpha.y <- rlnorm(n=1,meanlog = alpha.y.mean,sdlog = 1.5)
  b <- rnorm(n=1,mean=b.mean,sd=0.25)
  ## Get root state
  x0 <- psi.x[j]
  y0 <- psi.y[j] + b*x0
  true.model <- PCM(model=model.type,k=2)
  param <- c(y0,
             x0,
             alpha.y,
             0,
             -b*alpha.y,
             alpha.x,
             y0,
             x0,
             sigma.y,
             sigma.x)
  PCMParamLoadOrStore(true.model, param, offset=0, load=T)
  
  gene.param <- c(psi.y[j],psi.x[j],log(alpha.y),log(alpha.x),b,log(sigma.y),log(sigma.x))
  names(gene.param) <- paste0(c("Psi_Y_","Psi_X_","H_Y_","H_X_","Q_","Sigma_Y_","Sigma_X_"),j)
  true.param <- c(true.param,gene.param)
  modelOU <- PCM(model= model.type,k=2)
  data.pcm[[j]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  data.pcm[[j]] <- data.pcm[[j]][,1:num.species]
  likFun.list[[j]] <- PCMCreateLikelihood(data.pcm[[j]], ba.tree,modelOU,metaI = PCMInfoCpp)
} 



```

```{r warning = F}

pos.b.std <- grep("Q_Std",names(true.param))
pos.b <- grep("Q_[0-9]+",names(true.param))
start.values <- true.param[-c(pos.b.std,pos.b)]

pos.hy.mean <- grep("H_Y_Mean",names(start.values)) 
pos.hy.std <- grep("H_Y_Std",names(start.values)) 
pos.hx.mean <- grep("H_X_Mean",names(start.values)) 
pos.hx.std <- grep("H_X_Std",names(start.values)) 

pos.sigmay.mean <- grep("Sigma_Y_Mean",names(start.values)) 
pos.sigmay.std <- grep("Sigma_Y_Std",names(start.values)) 
pos.sigmax.mean <- grep("Sigma_X_Mean",names(start.values)) 
pos.sigmax.std <- grep("Sigma_X_Std",names(start.values)) 


pos.hx <- grep("H_X_[0-9]+",names(start.values)) 
pos.hy <- grep("H_Y_[0-9]+",names(start.values)) 
pos.b <- grep("Q_Mean",names(start.values))
pos.sigmax <- grep("Sigma_X_[0-9]+",names(start.values))
pos.sigmay <- grep("Sigma_Y_[0-9]+",names(start.values))

pos.psi <- grep("Psi",names(start.values))

MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LP.unc","LL","PR","HYP"),
                    parm.names=names(start.values), 
                    pos.hy.mean = pos.hy.mean,
                    pos.hy.std = pos.hy.std,
                    pos.hx.mean = pos.hx.mean,
                    pos.hx.std = pos.hx.std,
                    #pos.b.mean = pos.b.mean,
                    #pos.b.std = pos.b.std,
                    pos.sigmay.mean = pos.sigmay.mean,
                    pos.sigmay.std = pos.sigmay.std, 
                    pos.sigmax.mean = pos.sigmax.mean,
                    pos.sigmax.std = pos.sigmax.std,
                    pos.hy = pos.hy, 
                    pos.hx = pos.hx, 
                    pos.b = pos.b,
                    pos.sigmax=pos.sigmax,
                    pos.sigmay=pos.sigmay,
                    pos.psi=pos.psi,
                    prop = 1:length(start.values),
                    N=length(ba.tree$tip.label)*num.loci*2)



blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(3,4,8,9)
blockwise.sample.list[[2]] <- c(5)
blockwise.sample.list[[3]] <- c(1,2,6,7)
num.block <- length(blockwise.sample.list)
for (i in 1:num.loci)
{
  pos.psi.i <- grep(paste0("Psi_[YX]_",i,"$"),names(start.values))
  pos.h.i <- grep(paste0("H_[YX]_",i,"$"),names(start.values))
  pos.sigma.i <- grep(paste0("Sigma_[YX]_",i,"$"),names(start.values))
  blockwise.sample.list[[i+num.block]] <- c(pos.psi.i,pos.h.i,pos.sigma.i)
}

adapt.fit.beta.shared <- LaplacesDemon_local(ModelOUOU_shared_beta,
                                   MyData_OUOU,
                                   Initial.Values = start.values,
                                   Iterations = 10000,
                                   Algorithm = "RAM",
                                   Thinning = 1,
                                   Debug = list(DB.Model = F,
                                                DB.chol = T),
                                   Specs = list(alpha.star = 0.44,
                                                B = blockwise.sample.list,
                                                Dist="t",
                                                gamma = 2/3,
                                                n=0
                                   ))

```


# Test $\alpha$ shared

```{r}
Model_OUOU_alpha_shared <- function(parm, Data)
{
  
  ### Parameters
  ## Means are for a lognormal distribution, represent mean on the log-scale. Can be negative.
  b.mean.prior <- parm[Data[["pos.b.mean"]]]
  b.std.prior <- exp(parm[Data[["pos.b.std"]]])
  
  sigmay.mean.prior <- parm[Data[["pos.sigmay.mean"]]]
  sigmay.std.prior <- exp(parm[Data[["pos.sigmay.std"]]])
  
  sigmax.mean.prior <- parm[Data[["pos.sigmax.mean"]]]
  sigmax.std.prior <- exp(parm[Data[["pos.sigmax.std"]]])
  # 
  hy <- exp(parm[Data[["pos.hy.mean"]]])
  hx <- exp(parm[Data[["pos.hx.mean"]]])
  b <- parm[Data[["pos.b"]]]
  sigmay <- exp(parm[Data[["pos.sigmay"]]])
  sigmax <- exp(parm[Data[["pos.sigmax"]]])
  pos.psi <- Data[["pos.psi"]]
  
  ll_fun <- Data[["ll_fun"]]
  prop <- Data[["prop"]]
  gene.ll <- Data[["Gene.LL"]]
  offset <- 8
  ## Can use pos.psi[1] as check because parm should first have hyperparameters and then gene-specific parameters
  if (prop[1] >= pos.psi[1] && !is.null(gene.ll))
  {
    gene.index <- floor((prop[1] - offset - 1)/5) + 1
    other.ll <- sum(gene.ll[-gene.index])
    current.ll <- ll_fun[[gene.index]](c(parm[prop[1]] + parm[prop[3]]*parm[prop[2]],
                                         parm[prop[2]],
                                         hy,
                                         0,
                                         -hy * parm[prop[3]],
                                         hx,
                                         parm[prop[1]] + parm[prop[3]]*parm[prop[2]],
                                         parm[prop[2]],
                                         exp(parm[prop[4]]),
                                         exp(parm[prop[5]])))
  
    LL <- current.ll + other.ll
    gene.ll[gene.index] <- current.ll
    
  } else {
    num.genes <- (length(parm)-offset)/5
    gene.ll <- unlist(lapply(1:num.genes, function(current.loci)
    {
      par.index <- offset + 5*(current.loci-1) + 1
      ll <- ll_fun[[current.loci]](c(parm[par.index] + parm[par.index+2]*parm[par.index+1],
                                     parm[par.index+1],
                                     hy,
                                     0,
                                     -hy * parm[par.index+2],
                                     hx,
                                     parm[par.index] + parm[par.index+2]*parm[par.index+1],
                                     parm[par.index+1],
                                     exp(parm[par.index+3]),
                                     exp(parm[par.index+4])))
      
      ll
    })
    )
    LL <- sum(gene.ll)
  }
  
  PR <- sum(dlnorm(hy,meanlog = 0.25,sdlog = 1.5,log=T)) +
    sum(dlnorm(hx,meanlog = 0.25,sdlog = 1.5,log=T)) +
    sum(dnorm(b,mean = b.mean.prior,sd = b.std.prior,log=T)) +
    sum(dlnorm(sigmay,meanlog = sigmay.mean.prior,sdlog = sigmay.std.prior,log=T)) +
    sum(dlnorm(sigmax,meanlog = sigmax.mean.prior,sdlog = sigmax.std.prior,log=T)) +
    sum(dnorm(parm[pos.psi],mean = 0,sd = 1,log=T))

  HYP <- sum(dunif(c(sigmay.std.prior,
                          sigmax.std.prior,
                          b.std.prior),
                        min=0,max=2,log=T)) +
         sum(dunif(c(sigmay.mean.prior,
               sigmax.mean.prior),min=-5,max=0,log=T)) +
         dnorm(b.mean.prior,mean=0,sd=1,log=T)

  LP.unc <- LL + PR + HYP
  
  ## Apply correction for log-transformation of hyperparameters. Using lognormal for other parameters already corrects for this, but currently using uniform for hyperparameters
  LP <- LP.unc  + 
    sum(log(c(sigmay.std.prior, sigmax.std.prior,b.std.prior)))
  
  ## Parameter.LL is a bit of misnomer, is actually log posterior for each gene (no hyperpriors)
  Modelout <- list(LP=LP,Dev=-2*LL, Monitor=c(LP,LP.unc,LL,PR,HYP), yhat=1, parm=parm,Parameter.LL=gene.ll)
  return(Modelout)
}
```


```{r warning = F}

pos.hy.std <- grep("H_Y_Std",names(true.param)) 
pos.hx.std <- grep("H_X_Std",names(true.param)) 
pos.hx <- grep("H_X_[0-9]+",names(true.param)) 
pos.hy <- grep("H_Y_[0-9]+",names(true.param)) 
# pos.sigmay.std <- grep("Sigma_Y_Std",names(true.param)) 
# pos.sigmax.std <- grep("Sigma_X_Std",names(true.param))
start.values <- true.param[-c(pos.hy.std,pos.hx.std,pos.hy,pos.hx)]


pos.hy.mean <- grep("H_Y_Mean",names(start.values)) 
pos.hx.mean <- grep("H_X_Mean",names(start.values)) 

pos.b.mean <- grep("Q_Mean",names(start.values))
pos.b.std <- grep("Q_Std",names(start.values))

pos.sigmay.mean <- grep("Sigma_Y_Mean",names(start.values)) 
pos.sigmay.std <- grep("Sigma_Y_Std",names(start.values)) 
pos.sigmax.mean <- grep("Sigma_X_Mean",names(start.values))
pos.sigmax.std <- grep("Sigma_X_Std",names(start.values))

pos.b <- grep("Q_[0-9]+",names(start.values))
pos.sigmax <- grep("Sigma_X_[0-9]+",names(start.values))
pos.sigmay <- grep("Sigma_Y_[0-9]+",names(start.values))

pos.psi <- grep("Psi",names(start.values))


MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LP.unc","LL","PR","HYP"),
                    parm.names=names(start.values), 
                    pos.hy.mean = pos.hy.mean,
                    #pos.hy.std = pos.hy.std,
                    pos.hx.mean = pos.hx.mean,
                    #pos.hx.std = pos.hx.std,
                    pos.b.mean = pos.b.mean,
                    pos.b.std = pos.b.std,
                    pos.sigmay.mean = pos.sigmay.mean,
                    pos.sigmay.std = pos.sigmay.std, 
                    pos.sigmax.mean = pos.sigmax.mean,
                    pos.sigmax.std = pos.sigmax.std,
                    #pos.hy = pos.hy, 
                    #pos.hx = pos.hx, 
                    pos.b = pos.b,
                    pos.sigmax=pos.sigmax,
                    pos.sigmay=pos.sigmay,
                    pos.psi=pos.psi,
                    prop = 1:length(start.values),
                    N=length(ba.tree$tip.label)*num.loci*2)



blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(2,7,8)
blockwise.sample.list[[2]] <- c(3,4)
blockwise.sample.list[[3]] <- c(1,5,6)
num.block <- length(blockwise.sample.list)
for (i in 1:num.loci)
{
  pos.psi.i <- grep(paste0("Psi_[YX]_",i,"$"),names(start.values))
  pos.q.i <- grep(paste0("Q_",i,"$"),names(start.values))
  pos.sigma.i <- grep(paste0("Sigma_[YX]_",i,"$"),names(start.values))
  blockwise.sample.list[[i+num.block]] <- c(pos.psi.i,pos.q.i,pos.sigma.i)
}

adapt.fit.alpha.shared <- LaplacesDemon_local(Model_OUOU_alpha_shared,
                                   MyData_OUOU,
                                   Initial.Values = start.values,
                                   Iterations = 5000,
                                   Algorithm = "RAM",
                                   Thinning = 1,
                                   Debug = list(DB.Model = F,
                                                DB.chol = T),
                                   Specs = list(alpha.star = 0.35,
                                                B = blockwise.sample.list,
                                                Dist="t",
                                                gamma = 2/3,
                                                n=0
                                   ))

```


```{r}
plot(adapt.fit.alpha.shared$Monitor[,"LP"],type="l",main="Log(Posterior)")
plot(adapt.fit.alpha.shared$Monitor[,"LL"],type="l",main="Log(Likelihood)")
plot(adapt.fit.alpha.shared$Monitor[,"PR"],type="l",main="Log(Prior)")
plot(adapt.fit.alpha.shared$Posterior1[,"H_Y_Mean"],type="l",main="H_Y_Mean")
abline(h=alpha.y.mean)
plot(adapt.fit.alpha.shared$Posterior1[,"H_X_Mean"],type="l",main="H_X_Mean")
abline(h=alpha.x.mean)
plot(adapt.fit.alpha.shared$Posterior1[,"Q_Mean"],type="l",main="Q_Mean")
abline(h=0.65)
plot(adapt.fit.alpha.shared$Posterior1[,"Q_Std"],type="l",main="Q_Std")
abline(h=log(0.25))
plot(adapt.fit.alpha.shared$Posterior1[,"Sigma_Y_Mean"],type="l",main="Sigma_Y_Mean")
abline(h=sigma.y.mean)
plot(adapt.fit.alpha.shared$Posterior1[,"Sigma_Y_Std"],type="l",main="Sigma_Y_Std")
abline(h=log(1.5))
plot(adapt.fit.alpha.shared$Posterior1[,"Sigma_X_Mean"],type="l",main="Sigma_X_Mean")
abline(h=sigma.x.mean)
plot(adapt.fit.alpha.shared$Posterior1[,"Sigma_X_Std"],type="l",main="Sigma_X_Std")
abline(h=log(1.5))


```

## 50 species


```{r}
options(PCMBase.Threshold.EV = 1e-07)
options(PCMBase.Threshold.SV = 1e-08)
set.seed(25) # for reproducibility
num.loci <- 50 # number of loci
model.type <- "OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"

ba.tree <- ape::read.nexus("../Data/tree_11sp_noGpig.nex")
ba.tree <- phytools::force.ultrametric(ba.tree,method = "extend") # tree is not ultrametric due to apparent rounding error
tip.heights <- ips::tipHeights(ba.tree)
ba.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))

num.species <- length(ba.tree$tip.label)
# Simulate the optima of the 2 traits across loci
psi.x <- rnorm(n=num.loci,mean=0,sd=1)
psi.y <- rnorm(n=num.loci,mean=0,sd=1)

sigma.x.mean <- -2.3
sigma.y.mean <- -2.1
alpha.x.mean <- -3.8
alpha.y.mean <- -3.2
b.mean <- 0.65

data.pcm <- vector(mode="list",length=num.loci)
likFun.list <- vector(mode="list",length=num.loci)
true.param <- c(alpha.y.mean,log(1.5),alpha.x.mean,log(1.5),b.mean,log(0.25),sigma.y.mean,log(1.5),sigma.x.mean,log(1.5))
names(true.param) <- c("H_Y_Mean","H_Y_Std","H_X_Mean","H_X_Std","Q_Mean","Q_Std","Sigma_Y_Mean","Sigma_Y_Std","Sigma_X_Mean","Sigma_X_Std")
for(j in 1:num.loci)
{
  sigma.x <- rlnorm(n=1,meanlog = sigma.x.mean,sdlog = 1.5)
  sigma.y <- rlnorm(n=1,meanlog = sigma.y.mean,sdlog = 1.5)
  alpha.x <- rlnorm(n=1,meanlog = alpha.x.mean,sdlog = 1.5)
  alpha.y <- rlnorm(n=1,meanlog = alpha.y.mean,sdlog = 1.5)
  b <- rnorm(n=1,mean=b.mean,sd=0.25)
  ## Get root state
  x0 <- psi.x[j]
  y0 <- psi.y[j] + b*x0
  true.model <- PCM(model=model.type,k=2)
  param <- c(y0,
             x0,
             alpha.y,
             0,
             -b*alpha.y,
             alpha.x,
             y0,
             x0,
             sigma.y,
             sigma.x)
  PCMParamLoadOrStore(true.model, param, offset=0, load=T)
  
  gene.param <- c(psi.y[j],psi.x[j],log(alpha.y),log(alpha.x),b,log(sigma.y),log(sigma.x))
  names(gene.param) <- paste0(c("Psi_Y_","Psi_X_","H_Y_","H_X_","Q_","Sigma_Y_","Sigma_X_"),j)
  true.param <- c(true.param,gene.param)
  modelOU <- PCM(model= model.type,k=2)
  data.pcm[[j]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  data.pcm[[j]] <- data.pcm[[j]][,1:num.species]
  likFun.list[[j]] <- PCMCreateLikelihood(data.pcm[[j]], ba.tree,modelOU,metaI = PCMInfoCpp)
} 

```



```{r warning = F}

pos.hy.std <- grep("H_Y_Std",names(true.param)) 
pos.hx.std <- grep("H_X_Std",names(true.param)) 
pos.hx <- grep("H_X_[0-9]+",names(true.param)) 
pos.hy <- grep("H_Y_[0-9]+",names(true.param)) 
# pos.sigmay.std <- grep("Sigma_Y_Std",names(true.param)) 
# pos.sigmax.std <- grep("Sigma_X_Std",names(true.param))
start.values <- true.param[-c(pos.hy.std,pos.hx.std,pos.hy,pos.hx)]


pos.hy.mean <- grep("H_Y_Mean",names(start.values)) 
pos.hx.mean <- grep("H_X_Mean",names(start.values)) 

pos.b.mean <- grep("Q_Mean",names(start.values))
pos.b.std <- grep("Q_Std",names(start.values))

pos.sigmay.mean <- grep("Sigma_Y_Mean",names(start.values)) 
pos.sigmay.std <- grep("Sigma_Y_Std",names(start.values)) 
pos.sigmax.mean <- grep("Sigma_X_Mean",names(start.values))
pos.sigmax.std <- grep("Sigma_X_Std",names(start.values))

pos.b <- grep("Q_[0-9]+",names(start.values))
pos.sigmax <- grep("Sigma_X_[0-9]+",names(start.values))
pos.sigmay <- grep("Sigma_Y_[0-9]+",names(start.values))

pos.psi <- grep("Psi",names(start.values))


MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LP.unc","LL","PR","HYP"),
                    parm.names=names(start.values), 
                    pos.hy.mean = pos.hy.mean,
                    #pos.hy.std = pos.hy.std,
                    pos.hx.mean = pos.hx.mean,
                    #pos.hx.std = pos.hx.std,
                    pos.b.mean = pos.b.mean,
                    pos.b.std = pos.b.std,
                    pos.sigmay.mean = pos.sigmay.mean,
                    pos.sigmay.std = pos.sigmay.std, 
                    pos.sigmax.mean = pos.sigmax.mean,
                    pos.sigmax.std = pos.sigmax.std,
                    #pos.hy = pos.hy, 
                    #pos.hx = pos.hx, 
                    pos.b = pos.b,
                    pos.sigmax=pos.sigmax,
                    pos.sigmay=pos.sigmay,
                    pos.psi=pos.psi,
                    prop = 1:length(start.values),
                    N=length(ba.tree$tip.label)*num.loci*2)



blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(2,7,8)
blockwise.sample.list[[2]] <- c(3,4)
blockwise.sample.list[[3]] <- c(1,5,6)
num.block <- length(blockwise.sample.list)
for (i in 1:num.loci)
{
  pos.psi.i <- grep(paste0("Psi_[YX]_",i,"$"),names(start.values))
  pos.q.i <- grep(paste0("Q_",i,"$"),names(start.values))
  pos.sigma.i <- grep(paste0("Sigma_[YX]_",i,"$"),names(start.values))
  blockwise.sample.list[[i+num.block]] <- c(pos.psi.i,pos.q.i,pos.sigma.i)
}

adapt.fit.alpha.shared.50 <- LaplacesDemon_local(Model_OUOU_alpha_shared,
                                   MyData_OUOU,
                                   Initial.Values = start.values,
                                   Iterations = 5000,
                                   Algorithm = "RAM",
                                   Thinning = 1,
                                   Debug = list(DB.Model = F,
                                                DB.chol = T),
                                   Specs = list(alpha.star = 0.35,
                                                B = blockwise.sample.list,
                                                Dist="t",
                                                gamma = 2/3,
                                                n=0
                                   ))

```


```{r}
plot(adapt.fit.alpha.shared.50$Monitor[,"LP"],type="l",main="Log(Posterior)")
plot(adapt.fit.alpha.shared.50$Monitor[,"LL"],type="l",main="Log(Likelihood)")
plot(adapt.fit.alpha.shared.50$Monitor[,"PR"],type="l",main="Log(Prior)")
plot(adapt.fit.alpha.shared.50$Posterior1[,"H_Y_Mean"],type="l",main="H_Y_Mean")
abline(h=alpha.y.mean)
plot(adapt.fit.alpha.shared.50$Posterior1[,"H_X_Mean"],type="l",main="H_X_Mean")
abline(h=alpha.x.mean)
plot(adapt.fit.alpha.shared.50$Posterior1[,"Q_Mean"],type="l",main="Q_Mean")
abline(h=0.65)
plot(adapt.fit.alpha.shared.50$Posterior1[,"Q_Std"],type="l",main="Q_Std")
abline(h=log(0.25))
plot(adapt.fit.alpha.shared.50$Posterior1[,"Sigma_Y_Mean"],type="l",main="Sigma_Y_Mean")
abline(h=sigma.y.mean)
plot(adapt.fit.alpha.shared.50$Posterior1[,"Sigma_Y_Std"],type="l",main="Sigma_Y_Std")
abline(h=log(1.5))
plot(adapt.fit.alpha.shared.50$Posterior1[,"Sigma_X_Mean"],type="l",main="Sigma_X_Mean")
abline(h=sigma.x.mean)
plot(adapt.fit.alpha.shared.50$Posterior1[,"Sigma_X_Std"],type="l",main="Sigma_X_Std")
abline(h=log(1.5))


```


# Test full model on data simulated under simple model

```{r}
options(PCMBase.Threshold.EV = 1e-07)
options(PCMBase.Threshold.SV = 1e-08)
num.loci <- 100 # number of loci
model.type <- "OU__Global_X0__Global_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"
ba.tree <- ape::read.nexus("../Data/tree_11sp_noGpig.nex")
ba.tree <- phytools::force.ultrametric(ba.tree,method = "extend") # tree is not ultrametric due to apparent rounding error
min.edge <- min(ba.tree$edge.length)
ba.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))
ba.tree <- paleotree::minBranchLength(ba.tree,min.edge,modifyRootAge = F)

num.species <- length(ba.tree$tip.label)
# Simulate the optima of the 2 traits across loci
psi.x <- rnorm(n=num.loci,mean=0,sd=1)
psi.y <- rnorm(n=num.loci,mean=0,sd=1)

sigma.x.mean <- -2.8
sigma.y.mean <- -2.1
alpha.x.mean <- -3.8
alpha.y.mean <- -3.2
b.mean <- 0.65

data.pcm <- vector(mode="list",length=num.loci)
likFun.list <- vector(mode="list",length=num.loci)
true.param <- c(alpha.y.mean,log(1.5),alpha.x.mean,log(1.5),b.mean,log(0.25),sigma.y.mean,log(1.5),sigma.x.mean,log(1.5))
names(true.param) <- c("H_Y_Mean","H_Y_Std","H_X_Mean","H_X_Std","Q_Mean","Q_Std","Sigma_Y_Mean","Sigma_Y_Std","Sigma_X_Mean","Sigma_X_Std")
for(j in 1:num.loci)
{
  ## Get root state
  x0 <- psi.x[j]
  y0 <- psi.y[j] + b.mean*x0
  true.model <- PCM(model=model.type,k=2)
  param <- c(y0,
             x0,
             exp(alpha.y.mean),
             0,
            -b.mean*exp(alpha.y.mean),
             exp(alpha.x.mean),
             y0,
             x0,
             exp(sigma.y.mean),
             exp(sigma.x.mean))
  PCMParamLoadOrStore(true.model, param, offset=0, load=T)
  
  gene.param <- c(psi.y[j],psi.x[j],alpha.y.mean,alpha.x.mean,b.mean,sigma.y.mean,sigma.x.mean)
  names(gene.param) <- paste0(c("Psi_Y_","Psi_X_","H_Y_","H_X_","Q_","Sigma_Y_","Sigma_X_"),j)
  true.param <- c(true.param,gene.param)
  modelOU <- PCM(model= model.type,k=2)
  data.pcm[[j]] <- PCMSim(tree = ba.tree,model = true.model,X0 = true.model$X0)
  data.pcm[[j]] <- data.pcm[[j]][,1:num.species]
  likFun.list[[j]] <- PCMCreateLikelihood(data.pcm[[j]], ba.tree,modelOU,metaI = PCMInfoCpp)
} 

```


```{r}

start.values <- true.param

pos.hy.mean <- grep("H_Y_Mean",names(start.values)) 
pos.hy.std <- grep("H_Y_Std",names(start.values)) 
pos.hx.mean <- grep("H_X_Mean",names(start.values)) 
pos.hx.std <- grep("H_X_Std",names(start.values)) 

pos.sigmay.mean <- grep("Sigma_Y_Mean",names(start.values)) 
pos.sigmay.std <- grep("Sigma_Y_Std",names(start.values)) 
pos.sigmax.mean <- grep("Sigma_X_Mean",names(start.values)) 
pos.sigmax.std <- grep("Sigma_X_Std",names(start.values)) 

pos.b.std <- grep("Q_Std",names(true.param))
pos.b <- grep("Q_[0-9]+",names(true.param))

pos.hx <- grep("H_X_[0-9]+",names(start.values)) 
pos.hy <- grep("H_Y_[0-9]+",names(start.values)) 
pos.b <- grep("Q_Mean",names(start.values))
pos.sigmax <- grep("Sigma_X_[0-9]+",names(start.values))
pos.sigmay <- grep("Sigma_Y_[0-9]+",names(start.values))

pos.psi <- grep("Psi",names(start.values))

MyData_OUOU <- list(ll_fun = likFun.list,
                    mon.names = c("LP","LP.unc","LL","PR","HYP"),
                    parm.names=names(start.values), 
                    pos.hy.mean = pos.hy.mean,
                    pos.hy.std = pos.hy.std,
                    pos.hx.mean = pos.hx.mean,
                    pos.hx.std = pos.hx.std,
                    pos.b.mean = pos.b.mean,
                    pos.b.std = pos.b.std,
                    pos.sigmay.mean = pos.sigmay.mean,
                    pos.sigmay.std = pos.sigmay.std, 
                    pos.sigmax.mean = pos.sigmax.mean,
                    pos.sigmax.std = pos.sigmax.std,
                    pos.hy = pos.hy, 
                    pos.hx = pos.hx, 
                    pos.b = pos.b,
                    pos.sigmax=pos.sigmax,
                    pos.sigmay=pos.sigmay,
                    pos.psi=pos.psi,
                    prop = 1:length(start.values),
                    N=length(ba.tree$tip.label)*num.loci*2)



blockwise.sample.list <- list()
blockwise.sample.list[[1]] <- c(3,4,9,10)
blockwise.sample.list[[2]] <- c(5,6)
blockwise.sample.list[[3]] <- c(1,2,7,8)
num.block <- length(blockwise.sample.list)
for (i in 1:num.loci)
{
  pos.psi.i <- grep(paste0("Psi_[YX]_",i,"$"),names(start.values))
  pos.h.i <- grep(paste0("H_[YX]_",i,"$"),names(start.values))
  pos.q.i <- grep(paste0("Q_",i,"$"),names(start.values))
  pos.sigma.i <- grep(paste0("Sigma_[YX]_",i,"$"),names(start.values))
  blockwise.sample.list[[i+num.block]] <- c(pos.psi.i,pos.h.i,pos.q.i,pos.sigma.i)
}

adapt.fit.full.sim.simple <- LaplacesDemon_local(ModelOUOU_full_model,
                                   MyData_OUOU,
                                   Initial.Values = start.values,
                                   Iterations = 30000,
                                   Algorithm = "RAM",
                                   Thinning = 1,
                                   Debug = list(DB.Model = F,
                                                DB.chol = T),
                                   Specs = list(alpha.star = 0.35,
                                                B = blockwise.sample.list,
                                                Dist="t",
                                                gamma = 2/3,
                                                n=0
                                   ))





```



```{r}
plot(adapt.fit.full.sim.simple$Monitor[,"LP"],type="l",main="Log(Posterior)")
plot(adapt.fit.full.sim.simple$Monitor[,"LL"],type="l",main="Log(Likelihood)")
plot(adapt.fit.full.sim.simple$Monitor[,"PR"],type="l",main="Log(Prior)")
plot(adapt.fit.full.sim.simple$Posterior1[,"H_Y_Mean"],type="l",main="H_Y_Mean")
abline(h=alpha.y.mean)
plot(adapt.fit.full.sim.simple$Posterior1[,"H_Y_Std"],type="l",main="H_Y_Std")
plot(adapt.fit.full.sim.simple$Posterior1[,"H_X_Mean"],type="l",main="H_X_Mean")
abline(h=alpha.x.mean)
plot(adapt.fit.full.sim.simple$Posterior1[,"H_X_Std"],type="l",main="H_X_Std")
plot(adapt.fit.full.sim.simple$Posterior1[,"Q_Mean"],type="l",main="Q_Mean")
abline(h=0.65)
plot(adapt.fit.full.sim.simple$Posterior1[,"Q_Std"],type="l",main="Q_Std")
plot(adapt.fit.full.sim.simple$Posterior1[,"Sigma_Y_Mean"],type="l",main="Sigma_Y_Mean")
abline(h=sigma.y.mean)
plot(adapt.fit.full.sim.simple$Posterior1[,"Sigma_Y_Std"],type="l",main="Sigma_Y_Std")
plot(adapt.fit.full.sim.simple$Posterior1[,"Sigma_X_Mean"],type="l",main="Sigma_X_Mean")
abline(h=sigma.x.mean)
plot(adapt.fit.full.sim.simple$Posterior1[,"Sigma_X_Std"],type="l",main="Sigma_X_Std")



```