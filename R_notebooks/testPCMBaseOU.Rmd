---
title: "Testing OU model"
author: "Alex Cope"
date: '2023-05-08'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(PCMBase,lib.loc = "~/R_dev")
library(PCMBaseCpp)
library(adaptMCMC)
require(coda)
library(tidyverse)
library(cowplot)
library(ggpubr)
library(phytools)
library(extraDistr)


prior_ln <- function(params)
{
  params.present <- names(params)
  x0.index <- which(str_detect(params.present,"(X0)|(Theta)"))
  h.index <- which(str_detect(params.present,"(H)|(Sigma)"))
  pr <- 0
  if (length(x0.index) > 0)
  {
     pr <- pr + sum(dnorm(params[x0.index],mean=0,sd=1,log=T)) # assuming same prior
  }
  if (length(h.index) > 0)
  {
     pr  <- pr + sum(dlnorm(params[h.index],meanlog = 0.25,sdlog = 1.5,log=T))
  }
  return(pr)
}

prior_cauchy <- function(params)
{
  params.present <- names(params)
  x0.index <- which(str_detect(params.present,"(X0)|(Theta)"))
  h.index <- which(str_detect(params.present,"(H)|(Sigma)"))
  pr <- 0
  if (length(x0.index) > 0)
  {
     pr <- pr + sum(dnorm(params[x0.index],mean=0,sd=1,log=T)) # assuming same prior
  }
  if (length(h.index) > 0)
  {
     pr  <- pr + sum(dhcauchy(params[h.index],sigma=1,log=T))
  }
  return(pr)
}

# define the log-likelihood distribution
log_post_OU<- function(par,ll_fun,include.root=T,stationary=F,prior = prior_ln){
  if (!include.root)
  {
    par <- c(NA,NA,par)
  } else if (stationary){
    par.index <- which(str_detect(names(par),"Theta"))
    par <- c(par[par.index],par)
  }
  ll <- ll_fun(par)
  pr <- prior(par)
  return(ll+pr)
}

set.seed(5)
```

# Read in tree
```{r}
ba.tree <- read.nexus("../Data/tree_11sp_noGpig.nex")
plot(ba.tree)
ba.tree <- force.ultrametric(ba.tree,method = "extend")
plot(ba.tree)


```


# Testing OU model

## Create tree for OU

```{r}
tip.heights <- ips::tipHeights(ba.tree)
sim.tree <- pbtree(n = 50,scale = unname(tip.heights[1]))

```


## Simulate data under OU process

```{r}

# Simulate the traits
x0.a <- 0.25
x0.b <- -0.1
theta.a <- 0.5
theta.b <- -0.2
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.75
alpha.b <- 0.5
alpha.ab <- 0.2
alpha.ba <- 0.4

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
names(true.param) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = sim.tree,model = true.model,X0 = true.model$X0)
```


## Set up model with treating root as parameter
```{r}
modelOU.w.root <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun.w.root <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU.w.root,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param,ll_fun = likFun.w.root)
```

### Start MCMC at truth

```{r warning=FALSE}

n.batch <- 50000
fit.OU.w.root <- MCMC(log_post_OU, n.batch, init = true.param, scale = rep(1,length(true.param)),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.w.root)




```

```{r}
# Log Posterior
plot(fit.OU.w.root$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# X0
plot(fit.OU.w.root$samples[,1],type="l",ylab=expression("X"["0,A"]))
abline(h=x0.a)

plot(fit.OU.w.root$samples[,2],type="l",ylab=expression("X"["0,B"]))
abline(h=x0.b)

# H matrix
plot(fit.OU.w.root$samples[,3],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.w.root$samples[,4],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.w.root$samples[,5],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.w.root$samples[,6],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.w.root$samples[,7],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.w.root$samples[,8],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.w.root$samples[,9],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.w.root$samples[,10],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.w.root$samples[,11],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```

## Now fit assuming root state is not a parameter

PCMBase and PCMBaseCpp appear to play nicer with fitting models with the "Global_X0" specified, but making these values NA when calculating the loglikelihood.

```{r}
modelOU.wo.root <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun.wo.root <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU.wo.root,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param[3:11],ll_fun = likFun.wo.root,include.root = F)
```

### Start MCMC at truth

```{r warning=FALSE}

n.batch <- 50000
fit.OU.wo.root <- MCMC(log_post_OU, n.batch, init = true.param[3:11], scale = rep(1,length(true.param[3:11])),
            adapt = T, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun.wo.root,include.root = F)




```


```{r}
# Log Posterior
plot(fit.OU.wo.root$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# H matrix
plot(fit.OU.wo.root$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.wo.root$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.wo.root$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.wo.root$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.wo.root$samples[,5],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.wo.root$samples[,6],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.wo.root$samples[,7],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.wo.root$samples[,8],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.wo.root$samples[,9],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```

## Assume trait is at stationarity

```{r warning = F}
names(true.param) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
log_post_OU(true.param[3:11],stationary = T,ll_fun = likFun.w.root)

n.batch <- 50000
fit.OU.wo.root <- MCMC(log_post_OU, n.batch, init = true.param[3:11], scale = rep(1,length(true.param[3:11])),
            adapt = F, acc.rate = 0.25, gamma = 0.51, ll_fun=likFun.w.root,stationary=T)



```



```{r}
# Log Posterior
plot(fit.OU.wo.root$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)


# H matrix
plot(fit.OU.wo.root$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.wo.root$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.wo.root$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.wo.root$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.wo.root$samples[,5],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.wo.root$samples[,6],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.wo.root$samples[,7],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.wo.root$samples[,8],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.wo.root$samples[,9],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)


```

### Now try with random start
```{r warning = F}
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.theta.a <- rnorm(n=1,mean=0,sd=1)
start.theta.b <- rnorm(n=1,mean=0,sd=1)
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.theta.a,
               start.theta.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)


names(start.val) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")

# run the mcmc

n.batch <- 50000
fit.OU.rand.start <- MCMC(log_post_OU, n.batch, init = start.val[3:11], scale = rep(1,length(start.val[3:11])),
            adapt = n.batch * 0.5, acc.rate = 0.5, gamma = 2/3, ll_fun=likFun.w.root,stationary=T)





```


```{r}

# Log Posterior
plot(fit.OU.rand.start$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)

# H matrix
plot(fit.OU.rand.start$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.rand.start$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.rand.start$samples[,5],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.rand.start$samples[,6],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.rand.start$samples[,7],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.rand.start$samples[,8],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.rand.start$samples[,9],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)




```


## Larger values of $\alpha$

```{r}

# Simulate the traits
x0.a <- 0.25
x0.b <- -0.1
theta.a <- x0.a # assume stationarity
theta.b <- x0.b # assume stationarity
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 2
alpha.b <- 2.5
alpha.ab <- 1.3
alpha.ba <- 1.4

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
names(true.param) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = sim.tree,model = true.model,X0 = true.model$X0)
```

```{r}
modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param[3:11],ll_fun = likFun,stationary = T)
```


```{r warning = F}
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.theta.a <- rnorm(n=1,mean=0,sd=1)
start.theta.b <- rnorm(n=1,mean=0,sd=1)
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.theta.a,
               start.theta.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)


names(start.val) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")

# run the mcmc

n.batch <- 200000
fit.OU.rand.start <- MCMC(log_post_OU, n.batch, init = start.val[3:11], scale = rep(1,length(start.val[3:11])),
            adapt = n.batch * 0.75, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun,stationary=T,prior=prior_cauchy)







```



```{r}

# Log Posterior
plot(fit.OU.rand.start$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)

# H matrix
plot(fit.OU.rand.start$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.rand.start$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.rand.start$samples[,5],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.rand.start$samples[,6],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.rand.start$samples[,7],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.rand.start$samples[,8],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.rand.start$samples[,9],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)




```


# Tree height of 1

```{r}

sim.tree.scale.1 <- pbtree(n = 50,scale = 1)
plot(sim.tree.scale.1)
```


```{r}

# Simulate the traits
x0.a <- 0.25
x0.b <- -0.1
theta.a <- x0.a # assume stationarity
theta.b <- x0.b # assume stationarity
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 0.5
alpha.b <- 0.25
alpha.ab <- 0.3
alpha.ba <- 0.6

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
names(true.param) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = sim.tree.scale.1,model = true.model,X0 = true.model$X0)


```

```{r}
modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, sim.tree.scale.1, modelOU,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param[3:11],ll_fun = likFun,stationary = T,prior=prior_cauchy)
```


```{r warning = F}
set.seed(10)
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.theta.a <- rnorm(n=1,mean=0,sd=1)
start.theta.b <- rnorm(n=1,mean=0,sd=1)
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.theta.a,
               start.theta.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)


names(start.val) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")

# run the mcmc

n.batch <- 200000
fit.OU.rand.start <- MCMC(log_post_OU, n.batch, init = start.val[3:11], scale = rep(1,length(start.val[3:11])),
            adapt = n.batch * 0.75, acc.rate = 0.25, gamma = 2/3, ll_fun=likFun,stationary=T,prior=prior_cauchy)







```




## Increase number of species to 200

```{r}
set.seed(7)
tip.heights <- ips::tipHeights(ba.tree)
sim.tree <- pbtree(n = 200,scale = unname(tip.heights[1]))
plot(sim.tree)
```


```{r}

# Simulate the traits
x0.a <- 0.25
x0.b <- -0.1
theta.a <- x0.a # assume stationarity
theta.b <- x0.b # assume stationarity
sigma.a <- 0.5
sigma.ab <- 0.1
sigma.b <- 0.25
alpha.a <- 5
alpha.b <- 9
alpha.ab <- 2
alpha.ba <- 1

true.model <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)
true.param <- c(x0.a,x0.b,alpha.a,alpha.ba,alpha.ab,alpha.b,theta.a,theta.b,sigma.a,sigma.ab,sigma.b)
names(true.param) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")
PCMParamLoadOrStore(true.model, true.param, offset=0, load=T)


data.pcm <- PCMSim(tree = sim.tree,model = true.model,X0 = true.model$X0)


```

```{r}
modelOU <- PCM(model="OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x",k=2)

likFun <- PCMCreateLikelihood(data.pcm, sim.tree, modelOU,metaI = PCMInfoCpp)
true.post <- log_post_OU(par = true.param[3:11],ll_fun = likFun,stationary = T,prior=prior_cauchy)
```


```{r warning = F}
set.seed(12)
start.x0.a <- rnorm(n=1,mean=0,sd=1)
start.x0.b <- rnorm(n=1,mean=0,sd=1)
start.theta.a <- rnorm(n=1,mean=0,sd=1)
start.theta.b <- rnorm(n=1,mean=0,sd=1)
start.alpha.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.alpha.ba <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.a <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.ab <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)
start.sig.b <- rlnorm(1,meanlog = 0.25,sdlog = 1.5)

start.val <- c(start.x0.a,
               start.x0.b,
               start.alpha.a,
               start.alpha.ba,
               start.alpha.ab,
               start.alpha.b,
               start.theta.a,
               start.theta.b,
               start.sig.a,
               start.sig.ab,
               start.sig.b)


names(start.val) <- c("X0_A","X0_B","H_A","H_BA","H_AB","H_B","Theta_A","Theta_B","Sigma_A","Sigma_AB","Sigma_B")

# run the mcmc

n.batch <- 200000
fit.OU.rand.start <- MCMC(log_post_OU, n.batch, init = start.val[3:11], scale = rep(1,length(start.val[3:11])),
            adapt = n.batch*0.1, acc.rate = 0.5, gamma = 2/3, ll_fun=likFun,stationary=T,prior=prior_cauchy)

```


```{r}

# Log Posterior
plot(fit.OU.rand.start$log.p,type="l",ylab="Log(Posterior)")
abline(h=true.post)

# H matrix
plot(fit.OU.rand.start$samples[,1],type="l",ylab=expression(alpha["A"]))
abline(h=alpha.a)

plot(fit.OU.rand.start$samples[,2],type="l",ylab=expression(alpha["BA"]))
abline(h=alpha.ba)

plot(fit.OU.rand.start$samples[,3],type="l",ylab=expression(alpha["AB"]))
abline(h=alpha.ab)

plot(fit.OU.rand.start$samples[,4],type="l",ylab=expression(alpha["B"]))
abline(h=alpha.b)

# Theta

plot(fit.OU.rand.start$samples[,5],type="l",ylab=expression(theta["A"]))
abline(h=theta.a)

plot(fit.OU.rand.start$samples[,6],type="l",ylab=expression(theta["B"]))
abline(h=theta.b)


# Sigma matrix
plot(fit.OU.rand.start$samples[,7],type="l",ylab=expression(sigma["A"]))
abline(h=sigma.a)

plot(fit.OU.rand.start$samples[,8],type="l",ylab=expression(sigma["AB"]))
abline(h=sigma.ab)


plot(fit.OU.rand.start$samples[,9],type="l",ylab=expression(sigma["B"]))
abline(h=sigma.b)




```